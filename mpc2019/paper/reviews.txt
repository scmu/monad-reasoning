KOEN: Legend
  [ ] - todo
  [X] - done
  [?] - to check/discuss
  [0] - ignored

Dear authors,

On behalf of the program committee for the 13th International
Conference on Mathematics of Program Construction (MPC 2019),
I am delighted to inform you that your submission

  Handling Local State with Global State

as been accepted to appear in the conference.  Reviews are
appended below, and are also available from EasyChair.

Th
e final 'camera ready' version of your paper is due to be
submitted on *** 12th July 2019 ***, i.e. in four weeks time.
Please pay particular attention to any issues or concerns
that were raised in the reviews when preparing your final
version, as the program committee expects authors to
address these when revising their papers.

Please note that papers must adhere to the publication format
specified on the MPC web page (https://tinyurl.com/ybvxg8cl).
There is no prescribed page limit, but authors should strive
for brevity.  Revised papers will be submitted using EasyChair,
and the process for this will be advised in due course.

Graham Hutton
Program Chair, MPC 2019

SUBMISSION: 11
TITLE: Handling Local State with Global State


----------------------- REVIEW 1 ---------------------
SUBMISSION: 11
TITLE: Handling Local State with Global State
AUTHORS: Koen Pauwels, Tom Schrijvers and Shin-Cheng Mu

----------- Overall evaluation -----------
SCORE: 2 (accept)
----- TEXT:
This paper describes a technique for coping with non-determinism in functional programming using a "local state" construction, which copies the top level state to each branch, together with a method for "compiling" such programs into a more efficient (but harder to understand) "global state" version that does not include copying. Equivalence for the two program representations is justified wrt contextual equivalence. Proofs are supported by Coq mechanisations.

I rather liked this paper and think it should be accepted. The motivation and exposition is generally clear, and it studies, to a good degree of depth, an interesting problem. I found that the paper got progressively more difficult (and less accessible to the non-expert towards the end). In particular, the proof of contextual equivalence was rather challenging to follow. Fortunately, much of this later material is backed by Coq mechanisation, which provides the confidence needed in the results.


There are some aspects of the paper that could be improved.

[ ] 1. The intro seems rushed and doesn't seem to give a good overview of what's actually in the paper. I suggest that this be revisited and revised.
> K: I'll take a look at this soon.

[X] 2. In Sect 2.1, one would also expect non-determinism to be commutative and idempotent. Please explain why it isn't here.
> K: I added a paragraph but it needs to be checked.
> SCM: I think that paragraph is good!

[X] 3. I found the discussion around the justification of Theorem 1 regarding commutativity between the "state" and "non-determinism" confusing. I think it would help to give the exact equation that is desired.
> SCM: I added a definition of commutativity and a theorem in Section 2.2 (Combining Effects). Not sure it is the best location.

[?] 4. It would have been interesting to see an empirical comparison of the difference in running time between the local and global state versions on the already implemented n-queens example, especially as n tended towards large values.
> SCM: I don't think the actual speed of the global state program will be much faster, especially not for the n-Queens problem. We can ignore this comment, I think?
> K: I agree that our transformation will not improve the speed of the program much. Perhaps we can address the comment by de-emphasizing the speed argument? The negative review also took issue with the lack of benchmark; I believe this is to do with a misunderstanding of what the focus of the paper is (it's the proof technique more than the transformation itself). Since two reviewers made comments based on the same misunderstanding, we may need to communicate our focus more clearly.

Detailed comments
Abstract:
[X] - L6: I think you means "abstractions" instead of "abstract"?

Pg2:
[X] - Par 2, L2: "or case" --> "our case"
> SCM: Corrected.

[?] - Par 2: It seems that the last sentence should start the next paragraph?
> SCM: Is that the sentence "This is a convenient.."? If so I am not sure it is better moving the sentence...

[X] - Par 3, L2: "the the" --> "the"
> SCM: Corrected.

[ ] - Par 3: Last sentence is a bit of a jump. It think this paragraph could use some cleaning up as it is unclear upon a first read.
[ ] - Bullet 3.2: "the simulation" of what? This is unclear at this stage.
> K: These points are connected to a broader review of the intro.

Pg 3
- Below eqn (3):
   [X] - You should explain const and \cdot notations for completeness
   [X] - <$> isn't used until (Pg 7). This definition could be deferred until then.
> SCM: moved both (>>) and (<$>) to where there are first used.

[X] - Par "Nondeterminism": I don't think you need the "(a set of laws... )"
> SCM: I commented that out, although I prefer having it there.

Pg 4
[X] - Above eqn (8): Remove "are supposed to"

Pg 5
[X] - 2nd Par of "Global State Semantics": Remove "a bit"

Pg 6
[X] - Please remove the space after "Nothing" I found it confusing, especially in the first branch of "p >>= k"

Pg 8
[X] - Par above safeAcc: Remove "we are looking at"

Pg 9, Sect 3.2
[X] - Par 1: "Especially when ..." is not a sentence. Perhaps remove "Especially"?
[X] - Par 2: Remove "only"

Pg 10
[X] - Sentence after eqn (14) is very long; please rewrite.
[X] - Remove space before (5)
[X] - Sect 4.2, par 1. "Roll back to the previous state" - clarify whether this only happens when a solution is not found, or if it rolls back regardless of whether a solution is found.
> SCM: Added "regardless of whether a solution is found" --- correct?
> K: Yes :) (technically it depends on how you use it: for a given implementation of nondeterminisim you might have a function that just extracts the first result, for instance, but we never use it like that in the paper).

Pg 12
[X] - Par 1. In the second sentence, re-emphasise that the effects of backtrack is caused by $side$ in $put_R$
> SCM: I think it refers to the paragraph "To help build understanding...". Koen, can you take a look?
> K: I went into a bit more detail about what causes the backtracks, I hope this addresses the remark.

[X] - Par 2, last sentence: Extra ")" in the equation

Pg 13
[X] - L2: "told apart by" --> "differentiated by"

Pg 14
[X] - Fig 3: I'm confused by the notation. ([]) vs \overline{[]}. The second of these does not have parentheses - why? Are parentheses needed for the first?
> K: I indeed forgot the parens around the second

Pg 15

[X] - Sect 5.2, par 1, L3: Remove "can"

[X] - Sentence after Eqn (18) needs a rewrite

[X] - Eqn (21), (22), (23): Please add parentheses to help with parsing e.g., (21) should be:

(\bar{put} s p) \bar{[]} q  = \bar{put} s (p \bar{[]} q)

> SCM: I think it might help if we add more space around \bar{[]}.
> K: Yes, I added some space and I think it looks a lot better.
[X] > K: TODO now the parenthethised operator looks a bit weird though, should try to fix that.
    > K: It's a bit ugly, but I have introduced a separate mplusD operator which is the parenthethised version.

Pg 16
[ ] - Overfull text middle of page



----------------------- REVIEW 2 ---------------------
SUBMISSION: 11
TITLE: Handling Local State with Global State
AUTHORS: Koen Pauwels, Tom Schrijvers and Shin-Cheng Mu

----------- Overall evaluation -----------
SCORE: 2 (accept)
----- TEXT:
Synopsis:

The paper presents a whole program transformation for transforming
monadic programs with non-determinism and state effects. The purpose
of this transformation is to transform programs that require local
state semantics into a form so that it is safe to use global state
semantics. The authors also provide a case study that motivates the
problem. In short, the local state semantics is better for equational
reasoning while the global state semantics can yield better
performance characteristics. Some of the proofs have been formalised
in Coq.

Evaluation:

I really enjoyed reading this paper. It fits perfectly into MPC and
solves a well-motivated problem in an interesting way. The paper is
self-contained and written in an easy to understand style.

That being said the presentation could use some improvements: First of
all the writing could use some polish (more comments on that below).
Secondly, the paper, feels too long. The meat of the paper (section 5)
only starts at the bottom of page 13!

[ ] - This problem can be aleviated by removing some of the remarks that are
tangential to the contribution of the paper. Perhaps it could be possible to
move section 3 (motivation) towards the end of the paper as an extended example
or case study. I don't think the n-Queens example is referred to until the very
end of section 5 anyway.
> K: This is a big change and I'm not convinced it would flow better...

Detailed comments:

[?] - End of section 4.1. So what makes axiom (14) so special that it gets
 mentioned here but not the others
> K: I'm not sure yet how to clarify this more...

[X] - When giving the definition of put_R you should mention that this
 does not give the improved performance characteristics that you
 promised earlier in section 3.2. You can make a forward reference to
 section 5.6 to say that this will be partially addressed later.
> K: I added a comment about it at the end of the section.

[X] - On page 12, you write: "We wish that put_R, when run with a global
 state, satisﬁes laws (8) through (12)". This is confusing. Why do
 you want these laws, but not (13)? What does it mean for put_R to
 satisfy (12)?
> SCM: Should be (8) - (13).

[X] - On page 16 you write: "However, we will require that the order in
 which results are computed does not matter." What does that mean
 (especially given that the [] operator is not commutative)?
> K: Added an extra explanation starting from "This may seem contradictory at first glance."

Minor comments:

[X] - abstract: "[..] a mechanism of layered abstract by which effects can
 be implemented in terms of other effects." This does not make sense.

[X] - page 5: "These requirements imply that each nondeterministic branch
 has its own copy of the state." Why?
> SCM: added some explanations.

[X] - page 5, footnote: "a → [(a, s)]" -> "s → [(a, s)]"
> SCM: Corrected.

[X] - page 8: "Routine program calculation shows that we can check whether
 a placement [..]" This sentence needs to be reformulated.
> SCM: Rewritten. Hope the new sentence is clearer...

[X] - page 8: "non-determinism laws and (12) and (13)." Remove the first 'and'.
[X] - page 11: "variations of put". I only count one variation.
> SCM: changed to "variation of put".

[X] - page 12: In the last step of the calculation, you also need one of
 the monad laws.
> SCM: not sure what that is, but added "monad laws" in the comment anyway...

[X] - page 12: "When" -> "when"
> SCM: I can't find this one..
> K: I believe the reviewer means "When run in an initial state s_0..." (now on page 13). In that case they are mistaken, the capital letter is correct as the previous sentence ends with the period after expression (c) (though it is easy to miss).

[X] - page 16: "repect" -> "respect"
> SCM: corrected.

[?] - page 23, bottom: It would be nice to see the original implementation
 of n-Queens here as well. Also: there is an additional
 transformation performed where you insert an additional 'get' after
 the 'guard'.
> SCM: not sure what was meant by "original" implementation --- I don't think we need to repeat queens and qBody in Section 3.1. I don't understand what was meant by the "additional get after the guard", but I think it might be some minor transformation that we need not mention...
> K: I'm also unclear on what the reviewer meant here.

----------------------- REVIEW 3 ---------------------
SUBMISSION: 11
TITLE: Handling Local State with Global State
AUTHORS: Koen Pauwels, Tom Schrijvers and Shin-Cheng Mu

----------- Overall evaluation -----------
SCORE: -1 (weak reject)
----- TEXT:
This paper provides a case study in the kind of equational reasoning about effectful computations that has been advocated by Hutton and Fulger (2007) and Gibbons and Hinze (2011).  It adds an interesting twist in that it studies the question of how to reason about implementing one monad in terms of another, with influence from work on algebraic effects and handlers.

In an engaging way, the paper exposes unexpected subtlety in how nondeterminism and state should be combined, and the choices that must be made. The notion of local state, in which, for instance, different branches of a backtracking computation see their own local copies of the state, is contrasted with global state, in which a single state is threaded through computations, continuously being modified, but not reverted when the computation in a branch ends. It is these two views that give rise to the two monads. Finding a suitable monad for the global state semantics is surprisingly tricky.

Next, the n-queens example is used to motivate the need to transform a program written in local state style into one written using global state. While believing intuitively that this is indeed a useful, general transformation, I felt that the paper does not provide enough hard evidence for this. It is claimed that one might desire "the performance characteristics of global state semantics", but these are not described, either directly or via suitable citations. Section 3.2, on space usage of local state implementations, is annoyingly vague. It claims that it is easier to reason about resource usage in the global state semantics, but this claim is not justified in the paper. Earlier, in the Introduction, sequential search systems are mentioned and it is argued, very briefly, that using backtracking with undoing of state changes can be more efficient than recomputing the state from scratch. Perhaps further information and citations from this domain could provide better motivat!
ion than the paper currently does?

[ ] It is all very well to implement and prove that a transformation from local to global state preserves the functional semantics, but what about the non-functional semantics, in the form of memory use and number of computations or computation time? Surely the user needs some way to reason about these too? It seems unlikely that the n-queens example studied in the paper would actually display improved resource use after the local state to global state transformation is applied, and the paper even says this. For this reason, I think that it is a poor example to choose. It would be much better to choose an example where the transformation makes a significant change to the resource use of the program, and to demonstrate the reasoning needed to show this. Failing this, or, better still, in addition, a demonstration that the transformation can be applied to a more substantial example, leading to measured improvement in resource use in practice, would greatly strengthen the paper.

Ignoring these qualms, the paper's study of global state semantics and the laws they should satisfy, of an implementation satisfying the laws, and of how to transform from local to global state, is indeed interesting. That the implementation preserves the laws, and that the transformation preserves functional semantics are proved in Coq. The proof technique combining induction over syntax with contextual equivalence seems to be a novel contribution of the paper.


Minor comments

Abstract
[X] a mechanism of layered abstract        ?        missing word?   abstractions?
> SCM: should be abstractions. Corrected.

p 2
[X] or case study -> our case study
> SCM: corrected.

[X] the the       delete one
> SCM: corrected.

[X] There is a typo (in the form of an extra s parameter) in the types for monad (section 2.1).
> SCM: corrected.

section 3.1
[X] both as a fold or an unfold          both -> either
> SCM: revised.

[?] We wish to fuse the two phases to produce a faster implementation?
Explain why the fused version is expected to be faster? Also, is it actually faster?
> SCM: added "which allows branches generates a non-safe placement to be pruned earlier."

[X] it is natural trying to fuse them -> it is natural to try to fuse them
> SCM: revised.

end of section 4
[X] compaired against -> compared to
> SCM: corrected.

section 5
[X] formal treatment of non-deterministic global state monad             add "the" ?
> SCM: added.

[X] as are implementations -> as do implementations
> SCM: corrected.

[X] too narrow of a view   delete of
> SCM: corrected.

[X] semanticly -> semantically
> SCM: corrected.

section 6

[X] producere -> procedure
> SCM: corrected.

[X] applied the monadic setting -> applied in the monadic setting
> SCM: corrected.

[X] encoding axioms (or "effect theories") the type system         insert "in"
> SCM: corrected.
