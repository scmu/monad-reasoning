\documentclass{llncs}

% build using
%    lhs2TeX der-monad.lhs | pdflatex --jobname=der-monad

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords

%%format mplus = "([\!])"
%%format `mplus` = "\mathbin{[\!]}"
\newcommand{\smallBox}{\raisebox{-1pt}{\vstretch{1.1}{\hstretch{0.3}{\square}}}}



%%format seq = "(\otimes)"
%%format `seq` = "\mathbin{\otimes}"

%%format comb = "(\oplus)"
%%format `comb` = "\mathbin{\oplus}"










\makeatother
\EndFmtInput

\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{stmaryrd}
%\usepackage{mathptmx}
%\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{scalerel}
\usepackage{bussproofs}
\EnableBpAbbreviations
\usepackage{url}
\usepackage{subfig}
\usepackage{enumitem}
\usepackage{mdframed}
\usepackage{multicol}
\usepackage{graphicx}

\usepackage{doubleequals}


%\input{Preamble}

\setlength{\mathindent}{15pt}

\newcommand{\todo}[1]{{\bf [To do: #1]}}
\newcommand{\delete}[1]{}

\allowdisplaybreaks

\newcommand{\scm}[1]{\textcolor{teal}{#1}}
\newcommand{\koen}[1]{\textcolor{blue}{#1}}
\begin{document}


%% Title information
\title{Reasoning and Derivation of Monadic Programs}
\titlerunning{Deriving Monadic Programs}
\subtitle{A Case Study of Non-determinism and State}

\institute{Institute of Information Science, Academia Sinica, Taiwan, \email{scm@iis.sinica.edu.tw}
    \and Department of Computer Science, KU Leuven, Belgium, \email{first.last@cs.kuleuven.be}
    }
\author{Shin-Cheng Mu \inst{1} \and Tom Schrijvers \inst{2} \and Koen Pauwels \inst{2}}

\begin{abstract}
Equational reasoning is among the most important tools that functional programming provides us. Curiously, relatively less attention has been paid to reasoning about monadic programs. In this pearl we aim to develop theorems and patterns useful for the derivation of monadic programs, focusing on the intricate interaction between state and non-determinism. We derive a backtracking algorithm for the $n$-queens puzzle when each non-deterministic branch has its own local state. For the scenario where a global state is shared, we propose laws the monad should satisfy, and develop programming patterns and techniques to simulate local states.
\end{abstract}

\keywords{monads \and effects \and program derivation \and equational reasoning \and nondeterminism \and state}


\maketitle

%%include lhs2TeX.fmt
%%include forall.fmt
%%include polycode.fmt
%%include Formatting.fmt

\section{Introduction}

Equational reasoning is among the many gifts that functional programming offers us. Functional programs preserve a rich set of mathematical properties, which not only helps to prove properties about programs in a relatively simple and elegant manner, but also aids the development of programs. One may refine a clear but inefficient specification, stepwise through equational reasoning, to an efficient program whose correctness may not be obvious without such a derivation.

It is misleading if one says that functional programming does not allow side effects. In fact, even a purely functional language may allow a variety of side effects --- in a rigorous, mathematically manageable manner. Since the introduction of {\em monads} into the functional programming community~\cite{Moggi:89:Computational,Wadler:92:Monads}, it has become the main framework in which effects are modelled. Various monads were developed for different effects, from general ones such as IO, state, non-determinism, exception, continuation, environment passing, to specific purposes such as parsing. Numerous research were also devoted to producing practical monadic programs.

% Monad transformers~\cite{Liang:95:Monad} were introduced to allow modular construction of monads. Shortcomings of this approach were noticed, and it was proposed to see execution of monadic programs as interaction between programs and handlers~\cite{Plotkin:09:Handlers, Kiselyov:13:Extensible, KiselyovIshii:15:Freer}.

Hutton and Fulger~\cite{HuttonFulger:08:Reasoning} noted that relatively less attention has been paid to reasoning about monadic programs.
We believe that the observation is still true today, perhaps due to the impression that impure programs are bound to be difficult to reason about.
In fact, the laws of monads and their operators are sufficient to prove quite a number of useful properties about monadic programs.
The validity of these properties, proved using only these laws, is independent from the particular implementation of the monad.

This paper follows the trail of Hutton and Fulger~\cite{HuttonFulger:08:Reasoning} and~Gibbons and Hinze~\cite{GibbonsHinze:11:Just}, aiming to develop theorems and patterns that are useful for reasoning about monadic programs.
We focus on two effects --- non-determinism and state.
The interaction between non-determinism and state is known to be intricate.
When each non-deterministic branch has its own local state, we get a relatively well-behaved monad, providing a richer collection of properties to work with.
When all the non-deterministic branches share one global state, the properties of the monad is much less intuitive, as we shall see in this paper.

In this paper we consider problem specifications that use a monadic unfold to generate possible solutions, which are filtered using a \ensuremath{\Varid{scanl}}-like predicate.
We construct backtracking algorithms for such problems in two scenarios, in which the state is respectively local and global.
In the local-state case, we develop theorems that convert a variation of \ensuremath{\Varid{scanl}} to a \ensuremath{\Varid{foldr}} that uses the state monad, as well as theorems constructing hylomorphism.
For the case of global state, we study programming patterns that guarantee to restore the initial state after all non-deterministic branches, propose laws the global state monad should satisfy, and show that one may simulate local states using a global state.
The algorithms are used to solve the \ensuremath{\Varid{n}}-queens puzzle, our running example.
\section{Monad and Effect Operators}

A monad consists of a type constructor \ensuremath{\Conid{M}\mathbin{::}\mathbin{*}\to \mathbin{*}} and two operators \ensuremath{\Varid{return}\mathbin{::}\Varid{a}\to \Conid{M}\;\Varid{a}} and ``bind'' \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})\mathbin{::}\Conid{M}\;\Varid{a}\to (\Varid{a}\to \Conid{M}\;\Varid{b})\to \Conid{M}\;\Varid{b}} that satisfy the following {\em monad laws}:
\begin{align}
  \ensuremath{\Varid{return}\;\Varid{x}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}} &= \ensuremath{\Varid{f}\;\Varid{x}}\mbox{~~,} \label{eq:monad-bind-ret}\\
  \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{return}} &= \ensuremath{\Varid{m}} \mbox{~~,} \label{eq:monad-ret-bind}\\
  \ensuremath{(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{g}} &= \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{x}\to \Varid{f}\;\Varid{x}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{g})} \mbox{~~.}
    \label{eq:monad-assoc}
\end{align}
We also define \ensuremath{\Varid{m}_{1}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m}_{2}\mathrel{=}\Varid{m}_{1}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{const}\;\Varid{m}_{2}}, which has type \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}})\mathbin{::}\Varid{m}\;\Varid{a}\to \Varid{m}\;\Varid{b}\to \Varid{m}\;\Varid{b}}.
%\begin{figure}
% \vspace{-1cm}
% \caption{Some monadic operators we find handy for this paper.}
% \label{figure:monadic-operators}
% \end{figure}
Kleisli composition, denoted by \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}})}, composes two monadic operations \ensuremath{\Varid{a}\to \Conid{M}\;\Varid{b}} and \ensuremath{\Varid{b}\to \Conid{M}\;\Varid{c}} into an operation \ensuremath{\Varid{a}\to \Conid{M}\;\Varid{c}}.
The operator \ensuremath{(\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}})} applies a pure function to a monad.
%
% Operators |(<$>)| and |(<.>)| are monadic counterparts of function application and composition: |(<$>)| applies a pure function to a monad, while |(<.>)| composes a pure function after a monadic function.
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}){}\<[8]%
\>[8]{}\mathbin{::}(\Varid{a}\to \Conid{M}\;\Varid{b})\to (\Varid{b}\to \Conid{M}\;\Varid{c})\to \Varid{a}\to \Conid{M}\;\Varid{c}{}\<[E]%
\\
\>[B]{}(\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{g})\;\Varid{x}\mathrel{=}\Varid{f}\;\Varid{x}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{g}~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}(\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}){}\<[8]%
\>[8]{}\mathbin{::}(\Varid{a}\to \Varid{b})\to \Conid{M}\;\Varid{a}\to \Conid{M}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{f}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m}\mathrel{=}\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{return}\mathbin{\cdot}\Varid{f})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The following properties can be proved from their definitions and the monad laws:
\begin{align}
  \ensuremath{(\Varid{f}\mathbin{\cdot}\Varid{g})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m}} &= \ensuremath{\Varid{f}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{g}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})} \mbox{~~,}
    \label{eq:comp-ap-ap}\\
\ensuremath{(\Varid{f}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{g}} &= \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{g}\mathbin{\cdot}\Varid{f})} \mbox{~~,}
  \label{eq:comp-bind-ap}\\
\ensuremath{\Varid{f}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{k})} &= \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{x}\to \Varid{f}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{k}\;\Varid{x})}  \mbox{~~, \ensuremath{\Varid{x}} not free in \ensuremath{\Varid{f}}.}
  \label{eq:ap-bind-ap}
\end{align}

\paragraph{Effect and Effect Operators}
Monads are used to model effects, and each effect comes with its collection of operators. For example, to model non-determinism we assume two operators \ensuremath{\emptyset} and \ensuremath{(\talloblong)} ($\Varid{mplus}$), respectively modeling failure and choice. A state effect comes with operators \ensuremath{\Varid{get}} and \ensuremath{\Varid{put}}, which respectively reads from and writes to an unnamed state variable.

A program may involve more than one effect.
In Haskell, the type class constraint \ensuremath{\Conid{MonadPlus}} in the type of a program denotes that the program may use \ensuremath{\emptyset} or \ensuremath{(\talloblong)}, and possibly other effects, while \ensuremath{\Conid{MonadState}\;\Varid{s}} denotes that it may use \ensuremath{\Varid{get}} and \ensuremath{\Varid{put}}.
Some theorems in this paper, however, apply only to programs that, for example, use non-determinism and no other effects.
To talk about such programs, we use a slightly different notation.
We let the type \ensuremath{\Conid{M}_{\epsilon}\;\Varid{a}} denote a monad whose return type is \ensuremath{\Varid{a}} and, during whose execution, effects in the set \ensuremath{\epsilon} may occur.
This paper considers only two effects: non-determinism and state.
Non-determinism is denoted by \ensuremath{\Conid{N}}, for which we assume two operators \ensuremath{\emptyset\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}} and \ensuremath{(\talloblong)\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{a}}, where \ensuremath{\Conid{N}\in\epsilon}.
A state effect is denoted by \ensuremath{\Conid{S}\;\Varid{s}}, where \ensuremath{\Varid{s}} is the type of the state, with two operators \ensuremath{\Varid{get}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{s}} and \ensuremath{\Varid{put}\mathbin{::}\Varid{s}\to \Conid{M}_{\epsilon}\;()} where \ensuremath{\Conid{S}\;\Varid{s}\in\epsilon}.

We introduce a small language of effectful programs and a simple type system in Figure \ref{figure:type-system}.
If a program has type \ensuremath{\Conid{M}_{\Conid{N}}\;\Varid{a}}, we know that non-determinism is the {\em only effect} allowed.
Inference of effects is not unique, however: a program using \ensuremath{\emptyset} can be typed as both \ensuremath{\Conid{M}_{\Conid{N}}\;\Varid{a}} and \ensuremath{\Conid{M}_{\{\mskip1.5mu \Conid{N},\Conid{S}\;\Conid{Int}\mskip1.5mu\}}\;\Varid{a}}.
We sometimes denote the constraint on \ensuremath{\epsilon} in a type-class-like syntax, e.g \ensuremath{\emptyset\mathbin{::}\Conid{N}\in\epsilon\Rightarrow \Conid{M}_{\epsilon}\;\Varid{a}}.
All these are merely notational convenience --- the point is that the effects a program uses can be determined statically.

\begin{figure}
\small

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{80}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathcal{E}{}\<[8]%
\>[8]{}\mathrel{=}\mbox{pure, non-monadic expressons}{}\<[E]%
\\
\>[B]{}\mathcal{F}{}\<[8]%
\>[8]{}\mathrel{=}\mbox{functions returning monadic programs}~~{}\<[E]%
\\
\>[B]{}\mathcal{P}{}\<[8]%
\>[8]{}\mathrel{=}\Varid{return}\;\mathcal{E}\mid \mathcal{P}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\mathcal{F}\mid \emptyset\mid \mathcal{P}\mathbin{\talloblong}\mathcal{P}\mid \Varid{get}\mid \Varid{put}\;\mathcal{E}{}\<[80]%
\>[80]{}\mbox{~~ --- monadic progs}~~{}\<[E]%
\\
\>[B]{}\mathcal{T}{}\<[8]%
\>[8]{}\mathrel{=}\Varid{a}\mid \Varid{c}\mid \mathcal{T}\to \mathcal{T}\mid \Conid{M}_{\{\mskip1.5mu \mathcal{F}\mskip1.5mu\}}\;\mathcal{T}{}\<[80]%
\>[80]{}\mbox{~~ --- types}{}\<[E]%
\\
\>[B]{}\mathcal{F}{}\<[8]%
\>[8]{}\mathrel{=}\Conid{S}\;\Varid{a}\mid \Conid{S}\;\Varid{c}\mid \Conid{N}{}\<[80]%
\>[80]{}\mbox{~~ --- effects}{}\<[E]%
\\
\>[B]{}\quad\mbox{$a$ ranges over type variables,}{}\<[E]%
\\
\>[B]{}\quad\mbox{while $c$ ranges over for built-in type constants.}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%\vspace{-0.5cm}
\begin{align*}
\AXC{$\Gamma \vdash \ensuremath{\Varid{e}\mathbin{::}\Varid{a}} $}
\UIC{$\Gamma \vdash \ensuremath{\Varid{return}\;\Varid{e}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$}
\DP
%
&\quad
%
\AXC{$\Gamma \vdash \ensuremath{\Varid{m}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$}
\AXC{$\Gamma \vdash \ensuremath{\Varid{f}\mathbin{::}\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{b}}$}
\BIC{$\Gamma \vdash \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{b}}$}
\DP
\\
%
\AXC{\ensuremath{\Conid{N}\in\epsilon}}
\UIC{$\Gamma \vdash \ensuremath{\emptyset\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$}
\DP
%
&\quad
%
\AXC{$\Gamma \vdash \ensuremath{\Varid{m}_{1}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$\hspace{-0.5cm}}
\AXC{$\Gamma \vdash \ensuremath{\Varid{m}_{2}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$\hspace{-0.5cm}}
\AXC{\ensuremath{\Conid{N}\in\epsilon}}
\TIC{$\Gamma \vdash \ensuremath{\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}}$}
\DP
\\
\AXC{\ensuremath{\Conid{S}\;\Varid{s}\in\epsilon}}
\UIC{$\Gamma \vdash \ensuremath{\Varid{get}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{s}}$}
\DP
%
&\quad
%
\AXC{$\Gamma \vdash \ensuremath{\Varid{e}\mathbin{::}\Varid{s}}$}
\AXC{\ensuremath{\Conid{S}\;\Varid{s}\in\epsilon}}
\BIC{$\Gamma \vdash \ensuremath{\Varid{put}\;\Varid{e}\mathbin{::}\Conid{M}_{\epsilon}\;()}$}
\DP
\end{align*}
\caption{A small language and type system for effectful programs.}
\label{figure:type-system}
\end{figure}

\paragraph{Total, Finite Programs} Like in other literature on program derivation, we assume a set-theoretic semantics in which functions are total. Lists in this paper are inductive types, and unfolds generate finite lists too. Non-deterministic choices are finitely branching.
%In such a setting, hylomorphisms have unique solutions.
Given a concrete input, a function always expands to a finitely-sized expression consisting of syntax allowed by its type. We may therefore prove properties of a monad of type \ensuremath{\Conid{M}_{\epsilon}\;\Varid{a}} by structural induction over its syntax.

\section{Example: The \ensuremath{\Varid{n}}-Queens Problem}
\label{sec:queens}

Reasoning about monadic programs gets more interesting when more than one effect is involved.
Backtracking algorithms make good examples of programs that are stateful and non-deterministic, and the \ensuremath{\Varid{n}}-queens problem, also dealt with by Gibbons and Hinze~\cite{GibbonsHinze:11:Just}, is among the most well-known examples of backtracking.\footnote{Curiously, Gibbons and Hinze~\cite{GibbonsHinze:11:Just} did not finish their derivation and stopped at a program that exhaustively generates all permutations and tests each of them. Perhaps it was sufficient to demonstrate their point.}

In this section we present a specification of the problem, before transforming it into the form \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} (whose components will be defined later), which is the general form of problems we will deal with in this paper.
The specification is non-deterministic, but not stateful.
In the next few sections we will introduce state into the specification,
under different assumptions of the interaction between non-determinism and state.

\subsection{Non-Determinism}


Since the \ensuremath{\Varid{n}}-queens problem will be specified by a non-deterministic program,
we discuss non-determinism before presenting the specification.
We assume two operators \ensuremath{\emptyset} and \ensuremath{(\talloblong)}: the former denotes failure, while \ensuremath{\Varid{m}\mathbin{\talloblong}\Varid{n}} denotes that the computation may yield either \ensuremath{\Varid{m}} or \ensuremath{\Varid{n}}. What laws they should satisfy, however, can be a tricky issue. As discussed by Kiselyov~\cite{Kiselyov:15:Laws}, it eventually comes down to what we use the monad for. It is usually expected that \ensuremath{(\talloblong)} and \ensuremath{\emptyset} form a monoid. That is, \ensuremath{(\talloblong)} is associative, with \ensuremath{\emptyset} as its zero:
\begin{align}
\ensuremath{(\Varid{m}\mathbin{\talloblong}\Varid{n})\mathbin{\talloblong}\Varid{k}}~ &=~ \ensuremath{\Varid{m}\mathbin{\talloblong}(\Varid{n}\mathbin{\talloblong}\Varid{k})} \mbox{~~,}
  \label{eq:mplus-assoc}\\
\ensuremath{\emptyset\mathbin{\talloblong}\Varid{m}} ~=~ & \ensuremath{\Varid{m}} ~=~ \ensuremath{\Varid{m}\mathbin{\talloblong}\emptyset} \mbox{~~.}
  \label{eq:mzero-mplus}
\end{align}
It is also assumed that monadic bind distributes into \ensuremath{(\talloblong)} from the end,
while \ensuremath{\emptyset} is a left zero for \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})}:
\begin{alignat}{2}
  &\mbox{\bf left-distributivity}:\quad &
  \ensuremath{(\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}} ~&=~ \ensuremath{(\Varid{m}_{1}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f})\mathbin{\talloblong}(\Varid{m}_{2}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f})} \mbox{~~,}
  \label{eq:bind-mplus-dist}\\
  &\mbox{\bf left-zero}:\quad &
  \ensuremath{\emptyset\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}} ~&=~ \ensuremath{\emptyset} \label{eq:bind-mzero-zero} \mbox{~~.}
\end{alignat}
% Properties \eqref{eq:bind-mplus-dist} and \eqref{eq:bind-mzero-zero} are called {\em left-distributivity} and {\em left-zero}.
We will refer to the laws \eqref{eq:mplus-assoc}, \eqref{eq:mzero-mplus},
\eqref{eq:bind-mplus-dist}, \eqref{eq:bind-mzero-zero} collectively as the
\emph{nondeterminism laws}.
Other properties regarding \ensuremath{\emptyset} and \ensuremath{(\talloblong)} will be introduced when needed.

\subsection{Specification}
\label{sec:queens-spec}

{\arraycolsep=1.4pt
\begin{figure}
\centering
\subfloat[]{
$\scriptsize
\begin{array}{rrrrrrrrr}
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
0 & . & . & . & . & . & Q & . & .\\
1 & . & . & . & Q & . & . & . & .\\
2 & . & . & . & . & . & . & Q & .\\
3 & Q & . & . & . & . & . & . & .\\
4 & . & . & . & . & . & . & . & Q\\
5 & . & Q & . & . & . & . & . & .\\
6 & . & . & . & . & Q & . & . & .\\
7 & . & . & Q & . & . & . & . & .
\end{array}$
} %subfloat
\qquad
\subfloat[]{
$\scriptsize
\begin{array}{r|rrrrrrrr}
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\ \hline
0 & 0 & 1 & 2 & 3 & 4 & . & . & .\\
1 & 1 & 2 & 3 & 4 & . & . & . & .\\
2 & 2 & 3 & 4 & . & . & . & . & .\\
3 & 3 & 4 & . & . & . & . & . & .\\
4 & 4 & . & . & . & . & . & . & .\\
5 & . & . & . & . & . & . & . & 12\\
6 & . & . & . & . & . & . & 12& 13\\
7 & . & . & . & . & . & 12& 13& 14
\end{array}
$} %subfloat
\qquad
\subfloat[]{
$\scriptsize
\begin{array}{r|rrrrrrrr}
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\ \hline
0 & 0 &-1 & . & . & . &-5 &-6 &-7\\
1 & . & 0 &-1 & . & . & . &-5 &-6\\
2 & . & . & 0 &-1 & . & . & . &-5\\
3 & 3 & . & . & 0 & . & . & . & .\\
4 & 4 & 3 & . & . & 0 & . & . & .\\
5 & 5 & 4 & 3 & . & . & 0 & . & .\\
6 & 6 & 5 & 4 & 3 & . & . & 0 & .\\
7 & 7 & 6 & 5 & 4 & 3 & . & . & 0
\end{array}
$
} %subfloat
\caption{(a) This placement can be represented by \ensuremath{[\mskip1.5mu \mathrm{3},\mathrm{5},\mathrm{7},\mathrm{1},\mathrm{6},\mathrm{0},\mathrm{2},\mathrm{4}\mskip1.5mu]}. (b) Up diagonals.
(c) Down diagonals.}
\label{fig:queens-examples}
\end{figure}
} %arraycolsep

The aim of the puzzle is to place \ensuremath{\Varid{n}} queens on a \ensuremath{\Varid{n}} by \ensuremath{\Varid{n}} chess board such that no two queens can attack each other. Given \ensuremath{\Varid{n}}, we number the rows and columns by \ensuremath{[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]}. Since all queens should be placed on distinct rows and distinct columns, a potential solution can be represented by a permutation \ensuremath{\Varid{xs}} of the list \ensuremath{[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]}, such that \ensuremath{\Varid{xs}\mathbin{!!}\Varid{i}\mathrel{=}\Varid{j}} denotes that the queen on the $i$th column is placed on the $j$th row (see Figure \ref{fig:queens-examples}(a)). In this representation queens cannot be put on the same row or column, and the problem is reduced to filtering, among permutations of \ensuremath{[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]}, those placements in which no two queens are put on the same diagonal. The specification can be written as a non-deterministic program:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{queens}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow \Conid{Int}\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{queens}\;\Varid{n}\mathrel{=}\Varid{perm}\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;\Varid{safe}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{perm}} non-deterministically computes a permutation of its input, and the pure function \ensuremath{\Varid{safe}\mathbin{::}[\mskip1.5mu \Conid{Int}\mskip1.5mu]\to \Conid{Bool}} determines whether no queens are on the same diagonal. The monadic function \ensuremath{\Varid{filt}\;\Varid{p}\;\Varid{x}} returns \ensuremath{\Varid{x}} if \ensuremath{\Varid{p}\;\Varid{x}} holds, and fails otherwise:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{filt}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow (\Varid{a}\to \Conid{Bool})\to \Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{filt}\;\Varid{p}\;\Varid{x}\mathrel{=}\Varid{guard}\;(\Varid{p}\;\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{guard}} is a standard monadic function defined by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{guard}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow \Conid{Bool}\to \Conid{M}_{\epsilon}\;(){}\<[E]%
\\
\>[B]{}\Varid{guard}\;\Varid{b}\mathrel{=}\mathbf{if}\;\Varid{b}\;\mathbf{then}\;\Varid{return}\;()\;\mathbf{else}\;\emptyset~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This specification of \ensuremath{\Varid{queens}} generates all the permutations, before checking them one by one, in two separate phases. We wish to fuse the two phases and produce a faster implementation. The overall idea is to define \ensuremath{\Varid{perm}} in terms of an unfold, transform \ensuremath{\Varid{filt}\;\Varid{safe}} into a fold, and fuse the two phases into a {\em hylomorphism}~\cite{Meijer:91:Functional}. During the fusion, some non-safe choices can be pruned off earlier, speeding up the computation.

\paragraph{Permutation}
The monadic function \ensuremath{\Varid{perm}} can be written both as a fold or an unfold.
For this problem we choose the latter.
The function \ensuremath{\Varid{select}} non-deterministically splits a list into a pair containing one chosen element and the rest:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{select}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Conid{M}_{\epsilon}\;(\Varid{a},[\mskip1.5mu \Varid{a}\mskip1.5mu])~~.{}\<[E]%
\\
\>[B]{}\Varid{select}\;[\mskip1.5mu \mskip1.5mu]{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\emptyset{}\<[E]%
\\
\>[B]{}\Varid{select}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{return}\;(\Varid{x},\Varid{xs})\mathbin{\talloblong}((\Varid{id}\times(\Varid{x}\mathbin{:}))\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{select}\;\Varid{xs})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{(\Varid{f}\times\Varid{g})\;(\Varid{x},\Varid{y})\mathrel{=}(\Varid{f}\;\Varid{x},\Varid{g}\;\Varid{y})}.
For example, \ensuremath{\Varid{select}\;[\mskip1.5mu \mathrm{1},\mathrm{2},\mathrm{3}\mskip1.5mu]} yields one of \ensuremath{(\mathrm{1},[\mskip1.5mu \mathrm{2},\mathrm{3}\mskip1.5mu])}, \ensuremath{(\mathrm{2},[\mskip1.5mu \mathrm{1},\mathrm{3}\mskip1.5mu])} and \ensuremath{(\mathrm{3},[\mskip1.5mu \mathrm{1},\mathrm{2}\mskip1.5mu])}. The function call \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{y}} generates a list \ensuremath{[\mskip1.5mu \Varid{a}\mskip1.5mu]} from a seed \ensuremath{\Varid{y}\mathbin{::}\Varid{b}}. If \ensuremath{\Varid{p}\;\Varid{y}} holds, the generation stops. Otherwise an element and a new seed is generated using \ensuremath{\Varid{f}}. It is like the usual \ensuremath{\Varid{unfoldr}} apart from that \ensuremath{\Varid{f}}, and thus the result, is monadic:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{unfoldM}\mathbin{::}(\Varid{b}\to \Conid{Bool})\to (\Varid{b}\to \Conid{M}_{\epsilon}\;(\Varid{a},\Varid{b}))\to \Varid{b}\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{y}{}\<[16]%
\>[16]{}\mid \Varid{p}\;\Varid{y}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{return}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[16]{}\mid \Varid{otherwise}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{f}\;\Varid{y}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda (\Varid{x},\Varid{z})\to (\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Given these definitions, \ensuremath{\Varid{perm}} can be defined by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{perm}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{perm}\mathrel{=}\Varid{unfoldM}\;\Varid{null}\;\Varid{select}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Safety Check in a \ensuremath{\Varid{scanl}}}

We have yet to defined \ensuremath{\Varid{safe}}.
Representing a placement as a permutation allows an easy way to check whether two queens are put on the same diagonal.
An 8 by 8 chess board has 15 {\em up diagonals} (those running between bottom-left and top-right). Let them be indexed by \ensuremath{[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\mathrm{14}\mskip1.5mu]} (see Figure \ref{fig:queens-examples}(b)).
If we apply \ensuremath{\Varid{zipWith}\;(\mathbin{+})\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\mskip1.5mu]} to a permutation, we get the indices of the up-diagonals where the chess pieces are placed.
Similarly, there are 15 {\em down diagonals} (those running between top-left and bottom right).
By applying \ensuremath{\Varid{zipWith}\;(\mathbin{-})\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\mskip1.5mu]} to a permutation, we get the indices of their down-diagonals (indexed by \ensuremath{[\mskip1.5mu \mathbin{-}\mathrm{7}\mathinner{\ldotp\ldotp}\mathrm{7}\mskip1.5mu]}.
See Figure \ref{fig:queens-examples}(c)).
A placement is safe if the diagonals contain no duplicates:
% A safe placement is one whose up and down diagonals contains no duplicates:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ups},\Varid{downs}\mathbin{::}[\mskip1.5mu \Conid{Int}\mskip1.5mu]\to [\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{ups}\;{}\<[8]%
\>[8]{}\Varid{xs}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{zipWith}\;(\mathbin{+})\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\mskip1.5mu]\;\Varid{xs}{}\<[36]%
\>[36]{}~~,{}\<[E]%
\\
\>[B]{}\Varid{downs}\;{}\<[8]%
\>[8]{}\Varid{xs}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{zipWith}\;(\mathbin{-})\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\mskip1.5mu]\;\Varid{xs}{}\<[36]%
\>[36]{}~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{safe}{}\<[10]%
\>[10]{}\mathbin{::}[\mskip1.5mu \Conid{Int}\mskip1.5mu]\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{safe}\;\Varid{xs}{}\<[10]%
\>[10]{}\mathrel{=}\Varid{nodup}\;(\Varid{ups}\;\Varid{xs})\mathrel{\wedge}\Varid{nodup}\;(\Varid{downs}\;\Varid{xs})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{nodup}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Conid{Bool}} determines whether there is no duplication in a list.

The eventual goal is to transform \ensuremath{\Varid{filt}\;\Varid{safe}} into a \ensuremath{\Varid{foldr}}, to be fused with \ensuremath{\Varid{perm}}, an unfold that generates a list from left to right.
In order to do so, it helps if \ensuremath{\Varid{safe}} can be expressed in a computation that processes the list left-to-right, that is, a \ensuremath{\Varid{foldl}} or a \ensuremath{\Varid{scanl}}.
To derive such a definition we use the standard trick --- introducing accumulating parameters, and generalising \ensuremath{\Varid{safe}} to \ensuremath{\Varid{safeAcc}} below:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{safeAcc}\mathbin{::}(\Conid{Int},[\mskip1.5mu \Conid{Int}\mskip1.5mu],[\mskip1.5mu \Conid{Int}\mskip1.5mu])\to [\mskip1.5mu \Conid{Int}\mskip1.5mu]\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{safeAcc}\;(\Varid{i},\Varid{us},\Varid{ds})\;\Varid{xs}\mathrel{=}{}\<[25]%
\>[25]{}\Varid{nodup}\;\Varid{us'}\mathrel{\wedge}{}\<[39]%
\>[39]{}\Varid{nodup}\;\Varid{ds'}\mathrel{\wedge}{}\<[E]%
\\
\>[25]{}\Varid{all}\;(\not\in\Varid{us})\;\Varid{us'}\mathrel{\wedge}\Varid{all}\;(\not\in\Varid{ds})\;\Varid{ds'}~~,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;{}\<[10]%
\>[10]{}\Varid{us'}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{zipWith}\;(\mathbin{+})\;[\mskip1.5mu \Varid{i}\mathinner{\ldotp\ldotp}\mskip1.5mu]\;\Varid{xs}{}\<[E]%
\\
\>[10]{}\Varid{ds'}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{zipWith}\;(\mathbin{-})\;[\mskip1.5mu \Varid{i}\mathinner{\ldotp\ldotp}\mskip1.5mu]\;\Varid{xs}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It is a generalisation because \ensuremath{\Varid{safe}\mathrel{=}\Varid{safeAcc}\;(\mathrm{0},[\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])}.
By plain functional calculation, one may conclude that \ensuremath{\Varid{safeAcc}} can be defined using a variation of \ensuremath{\Varid{scanl}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{safeAcc}\;(\Varid{i},\Varid{us},\Varid{ds})\mathrel{=}\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;(\Varid{i},\Varid{us},\Varid{ds})~~,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;{}\<[10]%
\>[10]{}(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\oplus}\Varid{x}{}\<[31]%
\>[31]{}\mathrel{=}(\Varid{i}\mathbin{+}\mathrm{1},(\Varid{i}\mathbin{+}\Varid{x}\mathbin{:}\Varid{us}),(\Varid{i}\mathbin{-}\Varid{x}\mathbin{:}\Varid{ds})){}\<[E]%
\\
\>[10]{}\Varid{ok}\;(\Varid{i},(\Varid{x}\mathbin{:}\Varid{us}),(\Varid{y}\mathbin{:}\Varid{ds}))\mathrel{=}\Varid{x}\not\in\Varid{us}\mathrel{\wedge}\Varid{y}\not\in\Varid{ds}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{all}\;\Varid{p}\mathrel{=}\Varid{foldr}\;(\mathrel{\wedge})\;\Conid{True}\mathbin{\cdot}\Varid{map}\;\Varid{p}} and \ensuremath{\Varid{scanl}_{+}} is like \ensuremath{\Varid{scanl}}, but applies \ensuremath{\Varid{foldl}} to all non-empty prefixes of a list:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{scanl}_{+}\mathbin{::}(\Varid{b}\to \Varid{a}\to \Varid{b})\to \Varid{b}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{b}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;[\mskip1.5mu \mskip1.5mu]{}\<[25]%
\>[25]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[25]%
\>[25]{}\mathrel{=}(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{:}\Varid{scanl}_{+}\;(\oplus)\;(\Varid{st}\mathbin{\oplus}\Varid{x})\;\Varid{xs}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Operationally, \ensuremath{\Varid{safeAcc}} examines the list from left to right, while keeping a state \ensuremath{(\Varid{i},\Varid{us},\Varid{ds})}, where \ensuremath{\Varid{i}} is the current position being examined, while \ensuremath{\Varid{us}} and \ensuremath{\Varid{ds}} are respectively indices of all the up and down diagonals encountered so far. Indeed, in a function call \ensuremath{\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}}, the value \ensuremath{\Varid{st}} can be seen as a ``state'' that is explicitly carried around. This naturally leads to the idea: can we convert a \ensuremath{\Varid{scanl}_{+}} to a monadic program that stores \ensuremath{\Varid{st}} in its state? This is the goal of the next section.

As a summary of this section, after defining \ensuremath{\Varid{queens}}, we have transformed it into the following form:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{52}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}){}\<[52]%
\>[52]{}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This is the form of problems we will consider for the rest of this paper: problems whose solutions are generated by an monadic unfold, before being filtered by an \ensuremath{\Varid{filt}} that takes the result of a \ensuremath{\Varid{scanl}_{+}}.

\section{From Pure to Stateful \ensuremath{\Varid{scanl}}}
\label{sec:monadic-scanl}

The aim of this section is to turn the filtering phase \ensuremath{\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} into a \ensuremath{\Varid{foldr}}. For that we introduce a state monad to pass the state around.

The state effect provides two operators: \ensuremath{\Varid{get}\mathbin{::}\Conid{S}\;\Varid{s}\in\epsilon\Rightarrow \Conid{M}_{\epsilon}\;\Varid{s}} retrieves the state, while \ensuremath{\Varid{put}\mathbin{::}\Conid{S}\;\Varid{s}\in\epsilon\Rightarrow \Varid{s}\to \Conid{M}_{\epsilon}\;()} overwrites the state by the given value. They are supposed to satisfy the \emph{state laws}:
\begin{alignat}{2}
&\mbox{\bf put-put}:\quad &
\ensuremath{\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{st'}} &= \ensuremath{\Varid{put}\;\Varid{st'}}~~\mbox{,} \label{eq:put-put}\\
&\mbox{\bf put-get}:~ &
\ensuremath{\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{get}} &= \ensuremath{\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{st}} ~~\mbox{,} \label{eq:get-put}\\
&\mbox{\bf get-put}:~ &
\ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{put}} &= \ensuremath{\Varid{return}\;()} ~~\mbox{,} \label{eq:put-get}\\
&\mbox{\bf get-get}:\quad &
\ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{st}\to \Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{k}\;\Varid{st})} &= \ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{st}\to \Varid{k}\;\Varid{st}\;\Varid{st})}
~~\mbox{.} \label{eq:get-get}
\end{alignat}
% We define:
% \begin{code}
% overwrite st x  = put st >> return x {-"~~,"-}
% \end{code}
% such that |m >>= overwrite st| overwrites the state to |st| while returning the result of |m|.
% The laws \eqref{eq:put-put} -- \eqref{eq:get-get} will be respectively called |put|-|put|, |put|-|get|, |get|-|put|, and |get|-|get|.

\subsection{From \ensuremath{\Varid{scanl}_{+}} to monadic \ensuremath{\Varid{foldr}}}
\label{sec:scanl-scanlM}

Consider the following monadic variation of \ensuremath{\Varid{scanl}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{scanlM}\mathbin{::}\Conid{S}\;\Varid{s}\in\epsilon\Rightarrow (\Varid{s}\to \Varid{a}\to \Varid{s})\to \Varid{s}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Varid{s}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}\mathrel{=}\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;\Varid{x}\mathbin{\otimes}\Varid{m}\mathrel{=}{}\<[25]%
\>[25]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \mathbf{let}\;\Varid{st'}\mathrel{=}\Varid{st}\mathbin{\oplus}\Varid{x}{}\<[E]%
\\
\>[25]{}\mathbf{in}\;(\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{put}\;\Varid{st'}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It behaves like \ensuremath{\Varid{scanl}_{+}}, but stores the accumulated information in a monadic state, which is retrieved and stored in each step. The main body of the computation is implemented using a \ensuremath{\Varid{foldr}}.

To relate \ensuremath{\Varid{scanl}_{+}} and \ensuremath{\Varid{scanlM}}, one would like to have \ensuremath{\Varid{return}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;\Varid{xs})\mathrel{=}\Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}}.
However, the lefthand side does not alter the state, while the righthand side does.
One of the ways to make the equality hold is to manually backup and restore the state.
Define
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{protect}\;\Varid{m}~\mathrel{=}~\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{x}\to \Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We have
\begin{theorem}\label{lma:scanl-loop}
For all \ensuremath{(\oplus)\mathbin{::}(\Varid{s}\to \Varid{a}\to \Varid{s})}, \ensuremath{\Varid{st}\mathbin{::}\Varid{s}}, and \ensuremath{\Varid{xs}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{return}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;\Varid{xs})\mathbin{=}\Varid{protect}\;(\Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{theorem}
\begin{proof} By induction on \ensuremath{\Varid{xs}}. We present the case \ensuremath{\Varid{xs}\mathbin{:=}\Varid{x}\mathbin{:}\Varid{xs}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{protect}\;(\Varid{scanlM}\;(\oplus)\;\Varid{st}\;(\Varid{x}\mathbin{:}\Varid{xs})){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  expanding definitions, let \ensuremath{\Varid{st'}\mathrel{=}\Varid{st}\mathbin{\oplus}\Varid{x}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}((\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{put}\;\Varid{st'}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}))\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{r}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  by \ensuremath{\Varid{put}}-\ensuremath{\Varid{get}} \eqref{eq:get-put}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}((\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{put}\;\Varid{st'}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}))\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{r}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  by \eqref{eq:ap-bind-ap}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}({}\<[22]%
\>[22]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{st'}\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[22]{}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{r}\to {}\<[E]%
\\
\>[22]{}\Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{r}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[10]%
\>[10]{}\mbox{\commentbegin  by \ensuremath{\Varid{put}}-\ensuremath{\Varid{put}} \eqref{eq:put-put}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}({}\<[22]%
\>[22]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{put}\;\Varid{st'}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}{}\<[E]%
\\
\>[22]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{r}\to \Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{r}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  definitions of \ensuremath{\Varid{scanlM}} and \ensuremath{\Varid{protect}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{protect}\;(\Varid{scanlM}\;(\oplus)\;\Varid{st'}\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  induction  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{st'}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{return}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st'}\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[7]%
\>[7]{}\Varid{return}\;((\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{:}\Varid{scanl}_{+}\;(\oplus)\;(\Varid{st}\mathbin{\oplus}\Varid{x})\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[7]%
\>[7]{}\Varid{return}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;(\Varid{x}\mathbin{:}\Varid{xs}))~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%    $
\end{proof}
This proof is instructive due to the use of properties \eqref{eq:put-put} and \eqref{eq:get-put}, and that \ensuremath{(\Varid{st'}\mathbin{:})}, being a pure function, can be easily moved around using \eqref{eq:ap-bind-ap}.

We have learned that \ensuremath{\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}} can be turned into \ensuremath{\Varid{scanlM}\;(\oplus)\;\Varid{st}}, defined in terms of a stateful \ensuremath{\Varid{foldr}}.
In the definition, state is the only effect involved.
The next task is to transform \ensuremath{\Varid{filt}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} into a \ensuremath{\Varid{foldr}}.
The operator \ensuremath{\Varid{filt}} is defined using non-determinism. The transform therefore involves the interaction between two effects, a tricky topic this paper tries to deal with.

\subsection{Right-Distributivity and Local State}
\label{sec:right-distr-local-state}

We now digress a little to discuss one form of interaction between non-determinism and state.
When mixed with other effects, the following laws hold for some monads with non-determinism, but not all:
\begin{alignat}{2}
&\mbox{\bf right-distributivity}:\quad&
  \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{x}\to \Varid{f}_{1}\;\Varid{x}\mathbin{\talloblong}\Varid{f}_{2}\;\Varid{x})}~ &=~ \ensuremath{(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{1})\mathbin{\talloblong}(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{2})} \mbox{~~,}
    \label{eq:mplus-bind-dist}\\
&\mbox{\bf right-zero}:\quad&
  \ensuremath{\Varid{m}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset}~ &=~ \ensuremath{\emptyset} ~~\mbox{~~.}
    \label{eq:mzero-bind-zero}
\end{alignat}
With some implementations of the monad, it is likely that in the lefthand side of \eqref{eq:mplus-bind-dist}, the effect of \ensuremath{\Varid{m}} happens once, while in the righthand side it happens twice. In \eqref{eq:mzero-bind-zero}, the \ensuremath{\Varid{m}} on the lefthand side may incur some effects that do not happen in the righthand side.

Having \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero} leads to profound consequences on the semantics and implementation of monadic programs.
To begin with, \eqref{eq:mplus-bind-dist} implies that \ensuremath{(\talloblong)} be commutative: let \ensuremath{\Varid{m}\mathrel{=}\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}} and \ensuremath{\Varid{f}_{1}\mathrel{=}\Varid{f}_{2}\mathrel{=}\Varid{return}} in \eqref{eq:mplus-bind-dist}.
Implementation of such non-deterministic monads have been studied by Fischer~\cite{Fischer:11:Purely}.

When mixed with state, one consequence of \eqref{eq:mplus-bind-dist} is that \ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{s}\to \Varid{f}_{1}\;\Varid{s}\mathbin{\talloblong}\Varid{f}_{2}\;\Varid{s})\mathrel{=}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{1}\mathbin{\talloblong}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{2})}. That is, \ensuremath{\Varid{f}_{1}} and \ensuremath{\Varid{f}_{2}} get the same state regardless of whether \ensuremath{\Varid{get}} is performed outside or inside the non-deterministic branch.
Similarly, \eqref{eq:mzero-bind-zero} implies \ensuremath{\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset\mathrel{=}\emptyset} --- when a program fails, the changes it performed on the state can be discarded.
These requirements imply that each non-deterministic branch has its own copy of the state.
Therefore, we will refer to \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero} as \emph{local state laws} in this paper --- even though they do not explicitly mention state operators at all!
One monad satisfying the laws is \ensuremath{\Conid{M}_{\{\mskip1.5mu \Conid{N},\Conid{S}\;\Varid{s}\mskip1.5mu\}}\;\Varid{a}\mathrel{=}\Varid{s}\to [\mskip1.5mu (\Varid{a},\Varid{s})\mskip1.5mu]}, which is the same monad one gets by \ensuremath{\Conid{StateT}\;\Varid{s}\;(\Conid{ListT}\;\Conid{Identity})} in the Monad Transformer Library~\cite{MTL:14}.
With effect handling~\cite{Wu:14:Effect,KiselyovIshii:15:Freer}, the monad meets the requirements if we run the handler for state before that for list.

The advantage of having the local state laws is that we get many useful properties, which make this stateful non-determinism monad preferred for program calculation and reasoning.
In particular, non-determinism commutes with other effects.
\begin{definition}
Let \ensuremath{\Varid{m}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}} where \ensuremath{\Varid{x}} does not occur free, and \ensuremath{\Varid{n}\mathbin{::}\Conid{M}_{\delta}\;\Varid{b}} where \ensuremath{\Varid{y}} does not occur free. We say \ensuremath{\Varid{m}} and \ensuremath{\Varid{n}} commute if
\begin{equation} \label{eq:commute}
\begin{split}
  \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{x}\to \Varid{n}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{y}\to \Varid{f}\;\Varid{x}\;\Varid{y}~\mathrel{=}}\\
   \ensuremath{\Varid{n}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{y}\to \Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{x}\to \Varid{f}\;\Varid{x}\;\Varid{y}~~.}
\end{split}
\end{equation}
(Notice that \ensuremath{\Varid{m}} and \ensuremath{\Varid{n}} can also be typed as \ensuremath{\Conid{M}_{\epsilon\mathbin{\cup}\delta}}.) We say that \ensuremath{\Varid{m}} commutes with effect \ensuremath{\delta} if \ensuremath{\Varid{m}} commutes with any \ensuremath{\Varid{n}} of type \ensuremath{\Conid{M}_{\delta}\;\Varid{b}}, and that effects \ensuremath{\epsilon} and \ensuremath{\delta} commute if any \ensuremath{\Varid{m}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{a}} and \ensuremath{\Varid{n}\mathbin{::}\Conid{M}_{\delta}\;\Varid{b}} commute.
\end{definition}

\begin{theorem} \label{thm:nondet-commute}
If right-distributivity \eqref{eq:mplus-bind-dist} and right-zero \eqref{eq:mzero-bind-zero} hold
in addition to the monad laws stated before, non-determinism commutes with any effect \ensuremath{\epsilon}.
\end{theorem}
\begin{proof} By induction on syntax of \ensuremath{\Varid{n}}.
%   The aim is to prove \eqref{eq:commute}, where |n :: Me N a|, by structural induction on syntax of |n|. We show only the case |n := n1 `mplus` n2|:
% \begin{spec}
%    m >>= \x -> (n1 `mplus` n2) >>= \y -> f x y
% =   {- by \eqref{eq:bind-mplus-dist} -}
%    m >>= \x -> (n1 >>= f x) `mplus` (n2 x >>= f x)
% =   {- by \eqref{eq:mplus-bind-dist} -}
%    (m >>= \x -> n1 >>= f x) `mplus` (m >>= \x -> n2 >>= f x)
% =   {- induction -}
%    (n1 >>= \y -> m >>= \x -> f x y) `mplus` (n2 >>= \y -> m >>= \x -> f x y)
% =   {- by \eqref{eq:bind-mplus-dist} -}
%    (n1 `mplus` n2) >>= \y -> m >>= \x -> f x y {-"~~."-}
% \end{spec}
\end{proof}

For the rest of Section \ref{sec:monadic-scanl} and \ref{sec:nd-state-local}, we assume that \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero} hold.

\paragraph{Note} We briefly justify proofs by induction on the syntax tree.
Finite monadic programs can be represented by the free monad constructed out of \ensuremath{\Varid{return}} and the effect operators, which can be represented by an inductively defined data structure, and interpreted by effect handlers~\cite{Kiselyov:13:Extensible,KiselyovIshii:15:Freer}.
When we say two programs \ensuremath{\Varid{m}_{1}} and \ensuremath{\Varid{m}_{2}} are equal, we mean that they have the same denotation when interpreted by the effect handlers of the corresponding effects, for example, \ensuremath{\Varid{hdNondet}\;(\Varid{hdState}\;\Varid{s}\;\Varid{m}_{1})\mathrel{=}\Varid{hdNondet}\;(\Varid{hdState}\;\Varid{s}\;\Varid{m}_{2})}, where \ensuremath{\Varid{hdNondet}} and \ensuremath{\Varid{hdState}} are respectively handlers for nondeterminism and state.
Such equality can be proved by induction on some sub-expression in \ensuremath{\Varid{m}_{1}} or \ensuremath{\Varid{m}_{2}}, which are treated like any inductively defined data structure.
A more complete treatment is a work in progress, which cannot be fully covered in this paper.
({\em End of Note})



\subsection{Filtering Using a Stateful, Non-Deterministic Fold}
\label{sec:monadic-state-passing-local}

Having dealt with \ensuremath{\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}} in Section \ref{sec:scanl-scanlM},
in this section we aim to turn a filter of the form \ensuremath{\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} to a stateful and non-deterministic \ensuremath{\Varid{foldr}}.

We calculate, for all \ensuremath{\Varid{ok}}, \ensuremath{(\oplus)}, \ensuremath{\Varid{st}}, and \ensuremath{\Varid{xs}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;\Varid{xs}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[7]%
\>[7]{}\Varid{return}\;(\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}\;\Varid{xs})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to {}\<[E]%
\\
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  Theorem \ref{lma:scanl-loop}, definition of \ensuremath{\Varid{protect}}, monad law  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to \Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  non-determinism commutes with state  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ini}\to \Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{ini}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{protect}}, monad laws  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{protect}\;(\Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{guard}\mathbin{\cdot}\Varid{all}\;\Varid{ok})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Recall that \ensuremath{\Varid{scanlM}\;(\oplus)\;\Varid{st}\;\Varid{xs}\mathrel{=}\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}}.
The following theorem fuses a monadic \ensuremath{\Varid{foldr}} with a \ensuremath{\Varid{guard}} that uses its result.
\begin{theorem}\label{lma:foldr-guard-fusion}
Assume that state and non-determinism commute.
Let \ensuremath{(\otimes)} be defined as that in \ensuremath{\Varid{scanlM}} for any given \ensuremath{(\oplus)\mathbin{::}\Varid{s}\to \Varid{a}\to \Varid{s}}. We have that for all \ensuremath{\Varid{ok}\mathbin{::}\Varid{s}\to \Conid{Bool}} and \ensuremath{\Varid{xs}\mathbin{::}[\mskip1.5mu \Varid{a}\mskip1.5mu]}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{guard}\mathbin{\cdot}\Varid{all}\;\Varid{ok})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}~~,{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{x}\mathbin{\odot}\Varid{m}\mathrel{=}{}\<[25]%
\>[25]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[25]{}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}((\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{theorem}
\begin{proof} Unfortunately we cannot use a \ensuremath{\Varid{foldr}} fusion, since \ensuremath{\Varid{xs}}
occurs free in \ensuremath{\lambda \Varid{ys}\to \Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}}. Instead we
use a simple induction on \ensuremath{\Varid{xs}}. For the case \ensuremath{\Varid{xs}\mathbin{:=}\Varid{x}\mathbin{:}\Varid{xs}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}(\Varid{x}\mathbin{\otimes}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{guard}\mathbin{\cdot}\Varid{all}\;\Varid{ok})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  definition of \ensuremath{(\otimes)}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(((\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}))\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{guard}\mathbin{\cdot}\Varid{all}\;\Varid{ok})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  monad laws, \eqref{eq:comp-bind-ap}, and \eqref{eq:ap-bind-ap}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}\mathbin{:}\Varid{ys}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[8]%
\>[8]{}\mbox{\commentbegin  since \ensuremath{\Varid{guard}\;(\Varid{p}\mathrel{\wedge}\Varid{q})\mathrel{=}\Varid{guard}\;\Varid{q}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{guard}\;\Varid{p}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  nondeterminism commutes with state  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;(\Varid{x}\mathbin{:}\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  monad laws and definition of \ensuremath{(\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}})}   \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}(\Varid{foldr}\;(\otimes)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{ys}\to \Varid{guard}\;(\Varid{all}\;\Varid{ok}\;\Varid{ys})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  induction  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  definition of \ensuremath{(\odot)}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;(\Varid{x}\mathbin{:}\Varid{xs})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{proof}
This proof is instructive due to extensive use of commutativity.

In summary, we now have this corollary performing \ensuremath{\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} using a non-deterministic and stateful foldr:
\begin{corollary}\label{thm:filt-scanlp-foldr} Let \ensuremath{(\odot)} be defined as in Theorem \ref{lma:foldr-guard-fusion}. If state and non-determinism commute, we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})\;\Varid{xs}\mathbin{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{protect}\;(\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{corollary}

\section{Monadic Hylomorphism}
\label{sec:nd-state-local}

To recap what we have done,
we started with a specification of the form
\ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})}, where
\ensuremath{\Varid{f}\mathbin{::}\Varid{b}\to \Conid{M}_{\Conid{N}}\;(\Varid{a},\Varid{b})}, and have shown that
% for all |p|, |ok|, |oplus|, |st|, and |f :: b -> Me N (a,b)|,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  Corollary \ref{thm:filt-scanlp-foldr}, with \ensuremath{(\odot)} defined as in Theorem \ref{lma:foldr-guard-fusion}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{xs}\to \Varid{protect}\;(\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[8]%
\>[8]{}\mbox{\commentbegin  nondeterminism commutes with state  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{protect}\;(\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu]))~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
% Define |queensBody xs = perm xs >>= foldr odot (return [])|.
% We have
% \begin{spec}
% queens n =  get >>= \ini -> put (0,[],[]) >>
%             queensBody [0..n-1] >>= overwrite ini {-"~~."-}
% \end{spec}
The final task is to fuse \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}} with \ensuremath{\Varid{foldr}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])}.

\subsection{Monadic Hylo-Fusion}

In a pure setting, it is known that, provided that the unfolding phase terminates, \ensuremath{\Varid{foldr}\;(\otimes)\;\Varid{e}\mathbin{\cdot}\Varid{unfoldr}\;\Varid{p}\;\Varid{f}} is the unique solution of \ensuremath{\Varid{hylo}} in the equation below~\cite{Hinze:15:Conjugate}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{hylo}\;\Varid{y}{}\<[9]%
\>[9]{}\mid \Varid{p}\;\Varid{y}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{e}{}\<[E]%
\\
\>[9]{}\mid \Varid{otherwise}{}\<[22]%
\>[22]{}\mathrel{=}\mathbf{let}\;\Varid{f}\;\Varid{y}\mathrel{=}(\Varid{x},\Varid{z})\;\mathbf{in}\;\Varid{x}\mathbin{\otimes}\Varid{hylo}\;\Varid{z}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Hylomorphisms with monadic folds and unfolds are a bit tricky.
Pardo \cite{Pardo:01:Fusion} discussed hylomorphism for regular base functors, where the unfolding phase is monadic while the folding phase is pure.
As for the case when both phases are monadic, he noted ``the drawback ... is that they cannot be always transformed into a single function that avoids the construction of the intermediate data structure.''

For our purpose, we focus our attention on lists, and have a theorem fusing the monadic unfolding and folding phases under a side condition.
Given \ensuremath{(\otimes)\mathbin{::}\Varid{b}\to \Conid{M}_{\epsilon}\;\Varid{c}\to \Conid{M}_{\epsilon}\;\Varid{c}}, \ensuremath{\Varid{e}\mathbin{::}\Varid{c}}, \ensuremath{\Varid{p}\mathbin{::}\Varid{a}\to \Conid{Bool}}, and \ensuremath{\Varid{f}\mathbin{::}\Varid{a}\to \Conid{M}_{\epsilon}\;(\Varid{b},\Varid{a})} (with no restriction on \ensuremath{\epsilon}), consider the expression:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{foldr}\;(\otimes)\;(\Varid{return}\;\Varid{e})~\,\mathbin{::}~\,\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{c}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%Note that |p| is pure, while |f| and |otimes| are both monadic.
%The definition put no restrictions on what effects are allowed.
The following theorem says that this combination of folding and unfolding can be fused into one if \ensuremath{\Varid{f}} eventually terminates (in the sense explained at the end of this section) and for all \ensuremath{\Varid{x}} and \ensuremath{\Varid{m}}, \ensuremath{(\Varid{x}\mathbin{\otimes})} commutes with \ensuremath{\Varid{m}} in the sense that \ensuremath{\Varid{x}\mathbin{\otimes}\Varid{m}\,\mathrel{=}\,(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{y}\to \Varid{x}\mathbin{\otimes}\Varid{return}\;\Varid{y})}. That is, it does not matter whether the effects of \ensuremath{\Varid{m}} happens inside or outside \ensuremath{(\Varid{x}\mathbin{\otimes})}.
\begin{theorem} \label{thm:hylo-fusion}
For all \ensuremath{\epsilon}, \ensuremath{(\otimes)\mathbin{::}\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{c}\to \Conid{M}_{\epsilon}\;\Varid{c}}, \ensuremath{\Varid{m}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{c}}, \ensuremath{\Varid{p}\mathbin{::}\Varid{b}\to \Conid{Bool}}, \ensuremath{\Varid{f}\mathbin{::}\Varid{b}\to \Conid{M}_{\epsilon}\;(\Varid{a},\Varid{c})}, we have that \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{foldr}\;(\otimes)\;\Varid{m}\mathrel{=}\Varid{hyloM}\;(\otimes)\;\Varid{m}\;\Varid{p}\;\Varid{f}}, defined by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{hyloM}\;(\otimes)\;\Varid{m}\;\Varid{p}\;\Varid{f}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{p}\;\Varid{y}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{m}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{f}\;\Varid{y}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda (\Varid{x},\Varid{z})\to {}\<[37]%
\>[37]{}\Varid{x}\mathbin{\otimes}\Varid{hyloM}\;(\otimes)\;\Varid{m}\;\Varid{p}\;\Varid{f}\;\Varid{z}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
if \ensuremath{\Varid{x}\mathbin{\otimes}\Varid{n}\mathrel{=}\Varid{n}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return})} for all \ensuremath{\Varid{n}\mathbin{::}\Conid{M}_{\epsilon}\;\Varid{c}}, and that the relation \ensuremath{(\neg \mathbin{\cdot}\Varid{p})\mathbin{?}\mathbin{\cdot}\Varid{snd}\mathbin{\cdot}(\mathbin{\hstretch{0.7}{=\!\!<\!\!<}})\mathbin{\cdot}\Varid{f}} is well-founded. (See the note below.)
\end{theorem}
\begin{proof}
We start with showing that \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{foldr}\;(\otimes)\;\Varid{m}} is a fixed-point of the recursive equations of \ensuremath{\Varid{hyloM}}. When \ensuremath{\Varid{p}\;\Varid{y}} holds, it is immediate that
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{return}\;[\mskip1.5mu \mskip1.5mu]\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\otimes)\;\Varid{m}~\mathrel{=}~\Varid{m}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
When \ensuremath{\neg \;(\Varid{p}\;\Varid{y})}, we reason:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{y}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\otimes)\;\Varid{m}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{unfoldM}}, \ensuremath{\neg \;(\Varid{p}\;\Varid{y})}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\Varid{f}\;\Varid{y}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda (\Varid{x},\Varid{z})\to (\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}))\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{foldr}\;(\otimes)\;\Varid{m}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  monadic law \eqref{eq:monad-bind-ret} and \ensuremath{\Varid{foldr}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{f}\;\Varid{y}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}({}\<[16]%
\>[16]{}\lambda (\Varid{x},\Varid{z})\to \Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{xs}\to {}\<[E]%
\\
\>[16]{}\Varid{x}\mathbin{\otimes}\Varid{foldr}\;(\otimes)\;\Varid{m}\;\Varid{xs})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We focus on the expression inside the $\lambda$ abstraction:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{xs}\to \Varid{x}\mathbin{\otimes}\Varid{foldr}\;(\otimes)\;\Varid{m}\;\Varid{xs}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  assumption: \ensuremath{\Varid{x}\mathbin{\otimes}\Varid{n}\mathrel{=}\Varid{n}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return})}, see below  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{foldr}\;(\otimes)\;\Varid{m}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return})){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  since \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{f}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{g})\mathrel{=}(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{g}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\otimes)\;\Varid{m})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  by assumption \ensuremath{\Varid{x}\mathbin{\otimes}\Varid{m}\mathrel{=}\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return})}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{x}\mathbin{\otimes}(\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\otimes)\;\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To understand the first step, note that
\ensuremath{\Varid{h}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return})\,\mathrel{=}\,(\Varid{h}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}((\Varid{x}\mathbin{\otimes})\mathbin{\cdot}\Varid{return}))\;\Varid{xs}}.

Now that \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{foldr}\;(\otimes)\;\Varid{m}} is a fixed-point, we may conclude that it equals \ensuremath{\Varid{hyloM}\;(\otimes)\;\Varid{m}\;\Varid{p}\;\Varid{f}} if the latter has a unique fixed-point,
which is guaranteed by the well-foundedness condition.
See the note below.
\end{proof}

\paragraph{Note} Let \ensuremath{\Varid{q}} be a predicate, \ensuremath{\Varid{q}\mathbin{?}} is a relation defined by \ensuremath{\{\mskip1.5mu (\Varid{x},\Varid{x})\mid\Varid{q}\;\Varid{x}\mskip1.5mu\}}. The parameter \ensuremath{\Varid{y}} in \ensuremath{\Varid{unfoldM}} is called the {\em seed} used to generate the list. The relation \ensuremath{(\neg \mathbin{\cdot}\Varid{p})\mathbin{?}\mathbin{\cdot}\Varid{snd}\mathbin{\cdot}(\mathbin{\hstretch{0.7}{=\!\!<\!\!<}})\mathbin{\cdot}\Varid{f}} maps one seed to the next seed (where \ensuremath{(\mathbin{\hstretch{0.7}{=\!\!<\!\!<}})} is \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})} written reversed). If it is {\em well-founded}, intuitively speaking, the seed generation cannot go on forever and \ensuremath{\Varid{p}} will eventually hold. It is known that inductive types (those can be folded) and coinductive types (those can be unfolded) do not coincide in {\sf SET}. To allow a fold to be composed after an unfold, typically one moves to a semantics based on complete partial orders. However, it was shown~\cite{DoornbosBackhouse:95:Induction} that, in {\sf Rel}, when the relation generating seeds is well-founded, hylo-equations do have unique solutions. One may thus stay within a set-theoretic semantics. Such an approach is recently explored again~\cite{Hinze:15:Conjugate}. ({\em End of Note})

% \vspace{1em} % Koen: LLNCS docs ask to avoid vspace, can be allowed in "exceptional cases"
Theorem \ref{thm:hylo-fusion} does not rely on the \emph{local state laws} \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero}, and does not put restriction on \ensuremath{\epsilon}.
To apply the theorem to our particular case, we have to show that its preconditions hold for our particular \ensuremath{(\odot)} ---
for that we will need \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero}. In the lemma below we slightly generalise \ensuremath{(\odot)} in Theorem \ref{lma:foldr-guard-fusion}:
\begin{lemma} Assuming that state and non-determinism commute, and \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\emptyset\mathrel{=}\emptyset}. Given \ensuremath{\Varid{p}\mathbin{::}\Varid{a}\to \Varid{s}\to \Conid{Bool}}, \ensuremath{\Varid{next}\mathbin{::}\Varid{a}\to \Varid{s}\to \Varid{s}}, \ensuremath{\Varid{res}\mathbin{::}\Varid{a}\to \Varid{b}\to \Varid{b}}, define \ensuremath{(\odot)\mathbin{::}\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{b}\to \Conid{M}_{\epsilon}\;\Varid{b}} with \ensuremath{\{\mskip1.5mu \Conid{N},\Conid{S}\;\Varid{s}\mskip1.5mu\}\mathbin{\subseteq}\epsilon}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{x}\mathbin{\odot}\Varid{m}\mathrel{=}{}\<[17]%
\>[17]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{p}\;\Varid{x}\;\Varid{st})\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[17]{}\Varid{put}\;(\Varid{next}\;\Varid{x}\;\Varid{st})\mathbin{\hstretch{0.7}{>\!\!>}}(\Varid{res}\;\Varid{x}\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We have \ensuremath{\Varid{x}\mathbin{\odot}\Varid{m}\mathrel{=}\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}((\Varid{x}\mathbin{\odot})\mathbin{\cdot}\Varid{return})}.
\end{lemma}
\begin{proof}
Routine, using commutativity of state and non-determinism.
\end{proof}

\subsection{Summary, and Solving \ensuremath{\Varid{n}}-Queens}
\label{sec:solve-n-queens}

To conclude our derivation, a problem formulated as \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} can be solved by a hylomorphism. Define:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{solve}\mathbin{::}\{\mskip1.5mu \Conid{N},\Conid{S}\;\Varid{s}\mskip1.5mu\}\mathbin{\subseteq}\epsilon\Rightarrow {}\<[33]%
\>[33]{}(\Varid{b}\to \Conid{Bool})\to (\Varid{b}\to \Conid{M}_{\epsilon}\;(\Varid{a},\Varid{b}))\to (\Varid{s}\to \Conid{Bool})\to {}\<[E]%
\\
\>[33]{}(\Varid{s}\to \Varid{a}\to \Varid{s})\to \Varid{s}\to \Varid{b}\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{solve}\;\Varid{p}\;\Varid{f}\;\Varid{ok}\;(\oplus)\;\Varid{st}\;\Varid{z}\mathrel{=}\Varid{protect}\;(\Varid{put}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{hyloM}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{p}\;\Varid{f}\;\Varid{z})~~,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;\Varid{x}\mathbin{\odot}\Varid{m}\mathrel{=}{}\<[23]%
\>[23]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[23]{}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}((\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{corollary} \label{cor:unfold-filt-scanl-local}
% Given |p :: b -> Bool|, |f :: b -> Me eps (a,b)|, |z :: b|, |ok :: s -> Bool|, |oplus :: s -> a -> s|, |st :: s|, where |{N, S s} `sse` eps|,
If the relation \ensuremath{(\neg \mathbin{\cdot}\Varid{p})\mathbin{?}\mathbin{\cdot}\Varid{snd}\mathbin{\cdot}(\mathbin{\hstretch{0.7}{=\!\!<\!\!<}})\mathbin{\cdot}\Varid{f}} is well-founded, and \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero} hold in addition to the other laws, we have
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})\mathbin{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{solve}\;\Varid{p}\;\Varid{f}\;\Varid{ok}\;(\oplus)\;\Varid{st}\;\Varid{z}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{corollary}

\paragraph{\ensuremath{\Varid{n}}-Queens Solved}
Recall that
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{queens}\;\Varid{n}{}\<[11]%
\>[11]{}\mathrel{=}\Varid{perm}\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{filt}\;\Varid{safe}{}\<[E]%
\\
\>[11]{}\mathrel{=}\Varid{unfoldM}\;\Varid{null}\;\Varid{select}\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Varid{filt}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;(\mathrm{0},[\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu]))~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where the auxiliary functions \ensuremath{\Varid{select}}, \ensuremath{\Varid{ok}}, \ensuremath{(\oplus)} are defined in Section \ref{sec:queens}.
The function \ensuremath{\Varid{select}} cannot be applied forever since the length of the given list decreases after each call.
Therefore, Corollary \ref{cor:unfold-filt-scanl-local} applies, and we have \ensuremath{\Varid{queens}\;\Varid{n}\mathrel{=}\Varid{solve}\;\Varid{null}\;\Varid{select}\;\Varid{ok}\;(\oplus)\;(\mathrm{0},[\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]}.
Expanding the definitions we get:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{queens}\mathbin{::}\{\mskip1.5mu \Conid{N},\Conid{S}\;(\Conid{Int},[\mskip1.5mu \Conid{Int}\mskip1.5mu],[\mskip1.5mu \Conid{Int}\mskip1.5mu])\mskip1.5mu\}\mathbin{\subseteq}\epsilon\Rightarrow \Conid{Int}\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{queens}\;\Varid{n}\mathrel{=}\Varid{protect}\;(\Varid{put}\;(\mathrm{0},[\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{queensBody}\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu])~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{queensBody}\mathbin{::}\{\mskip1.5mu \Conid{N},\Conid{S}\;(\Conid{Int},[\mskip1.5mu \Conid{Int}\mskip1.5mu],[\mskip1.5mu \Conid{Int}\mskip1.5mu])\mskip1.5mu\}\mathbin{\subseteq}\epsilon\Rightarrow [\mskip1.5mu \Conid{Int}\mskip1.5mu]\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{queensBody}\;[\mskip1.5mu \mskip1.5mu]{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{return}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{queensBody}\;\Varid{xs}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{select}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda (\Varid{x},\Varid{ys})\to {}\<[E]%
\\
\>[19]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{st}\to \Varid{guard}\;(\Varid{ok}\;(\Varid{st}\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[19]{}\Varid{put}\;(\Varid{st}\mathbin{\oplus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}((\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{queensBody}\;\Varid{ys})~~,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;{}\<[10]%
\>[10]{}(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\oplus}\Varid{x}\mathrel{=}(\mathrm{1}\mathbin{+}\Varid{i},(\Varid{i}\mathbin{+}\Varid{x})\mathbin{:}\Varid{us},(\Varid{i}\mathbin{-}\Varid{x})\mathbin{:}\Varid{ds}){}\<[E]%
\\
\>[10]{}\Varid{ok}\;(\anonymous ,\Varid{u}\mathbin{:}\Varid{us},\Varid{d}\mathbin{:}\Varid{ds})\mathrel{=}(\Varid{u}\notin \Varid{us})\mathrel{\wedge}(\Varid{d}\notin \Varid{ds})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This completes the derivation of our first algorithm for the \ensuremath{\Varid{n}}-queens problem.

\section{Non-Determinism with Global State}
\label{sec:nd-state-global}

For a monad with both non-determinism and state, the local state laws imply that each non-deterministic branch has its own state. This is not costly for states consisting of linked data structures, for example the state \ensuremath{(\Conid{Int},[\mskip1.5mu \Conid{Int}\mskip1.5mu],[\mskip1.5mu \Conid{Int}\mskip1.5mu])} in the \ensuremath{\Varid{n}}-queens problem. In some applications, however, the state might be represented by data structures, e.g. arrays, that are costly to duplicate. For such practical concerns, it is worth considering the situation when all non-deterministic branches share one global state.

Non-deterministic monads with a global state, however, is rather tricky.
One might believe that \ensuremath{\Conid{M}\;\Varid{a}\mathrel{=}\Varid{s}\to ([\mskip1.5mu \Varid{a}\mskip1.5mu],\Varid{s})} is a natural implementation of such a monad.
The usual, naive implementation of \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})} using this representation, however, does not satisfy left-distributivity \eqref{eq:bind-mplus-dist}, violates monad laws, and is therefore not even a monad.
%See Section \ref{sec:conclusion} for previous work on construction of a correct monad.
\footnote{
The type \ensuremath{\Conid{ListT}\;(\Conid{State}\;\Varid{s})} generated using the now standard Monad Transformer Library~\cite{MTL:14} expands to essentially the same implementation, and is flawed in the same way.
More careful implementations of \ensuremath{\Conid{ListT}}, which does satisfy \eqref{eq:bind-mplus-dist} and the monad laws, have been proposed~\cite{Gale:07:ListT,Volkov:14:list-t}.
Effect handlers (e.g. Wu~\cite{Wu:14:Effect} and Kiselyov and Ishii~\cite{KiselyovIshii:15:Freer}) do produce correct implementations if we run the handler for non-determinism before that of state.
}

Even after we do have a non-deterministic, global-state passing implementation that is a monad, its semantics can sometimes be surprising.
In \ensuremath{\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}}, the computation \ensuremath{\Varid{m}_{2}} receives the state computed by \ensuremath{\Varid{m}_{1}}.
Thus \ensuremath{(\talloblong)} is still associative, but certainly cannot be commutative.
As mentioned in Section \ref{sec:right-distr-local-state}, right-distributivity \eqref{eq:mplus-bind-dist} implies commutativity of \ensuremath{(\talloblong)}.
Contravariantly, \eqref{eq:mplus-bind-dist} cannot be true when the state is global.
Right-zero \eqref{eq:mzero-bind-zero} does not hold either: \ensuremath{\emptyset} simply fails, while \ensuremath{\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset}, for example, fails with an altered global state.
These significantly limit the properties we may have.

The aim of this section is to appeal to intuition and see what happens when we work with a global state monad:
what pitfall we may encounter, and what programming pattern we may use,
to motivate the more formal treatment in Section~\ref{sec:ctxt-trans}.

\subsection{The Global State Law}
\label{sec:laws-global-state}

We have already discussed general laws for nondeterministic monads
(laws~\eqref{eq:mplus-assoc} through~\eqref{eq:bind-mzero-zero}),
as well as laws which govern the interaction between state and nondeterminism in
a local state setting (laws~\eqref{eq:mplus-bind-dist} and
\eqref{eq:mzero-bind-zero}).
For global state semantics, an alternative law is required to govern the
interactions between nondeterminism and state.
We call this the \emph{global state law}, to be discussed in more detail in Section~\ref{sec:model-global-state-sem}.
\begin{alignat}{2}
&\mbox{\bf put-or}:\quad&
  \ensuremath{(\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m})\mathbin{\talloblong}\Varid{n}} &=~ \ensuremath{\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}(\Varid{m}\mathbin{\talloblong}\Varid{n})}~ \mbox{~~,}
    \label{eq:put-or}
\end{alignat}
This law allows the lifting of a \ensuremath{\Varid{put}} operation from the left
branch of a nondeterministic choice, an operation which does not preserve
meaning under local-state semantics:
suppose for example that \ensuremath{\Varid{m}\mathrel{=}\emptyset}, then by
\eqref{eq:mzero-bind-zero} and~\eqref{eq:mzero-mplus}, the left-hand side of
the equation is equal to \ensuremath{\Varid{n}}, whereas by
~\eqref{eq:mzero-mplus},
the right-hand side of the equation is equal to \ensuremath{\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{n}}.

By itself, this law leaves us free to choose from a large space of semantic domain
implementations with different properties.
For example, in any given implementation, the programs \ensuremath{\Varid{return}\;\Varid{x}\mathbin{\talloblong}\Varid{return}\;\Varid{y}} and
\ensuremath{\Varid{return}\;\Varid{y}\mathbin{\talloblong}\Varid{return}\;\Varid{x}} may be considered semantically identical, or they may be
considered semantically distinct.
The same goes for the programs \ensuremath{\Varid{return}\;\Varid{x}\mathbin{\talloblong}\Varid{return}\;\Varid{x}} and \ensuremath{\Varid{return}\;\Varid{x}},
or the programs \ensuremath{(\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x})\mathbin{\talloblong}\Varid{m}} and
\ensuremath{(\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x})\mathbin{\talloblong}\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m}}.
Additional axioms will be introduced as needed to cover these properties.

%We will also require another property which we will only introduce informally
%here (and formulate more clearly later).
%In global state semantics, the right-distributivity rule does not hold in
%general. However, there are some cases where an operation does distribute over
%non-deterministic choice while preserving semantics; more precisely, this is the
%case when
%\begin{enumerate}
%\item the left branch of the choice operator does not modify the state,
%\item the operation that is distributed over the choice operator is idempotent
%  with respect to the state, and
%\item this operation is at the top-level of the program (i.e. it is not a
%  subterm of a larger term).
%\end{enumerate}
%This last property is a ``global'' property.
%In order to formulate it correctly, we first need to develop a notation that
%allows us to distinguish between local and global properties.
%We will do this in Section~\ref{sec:ctxt-trans}.

\subsection{Chaining Using Non-deterministic Choice}
\label{sec:chaining}

In backtracking algorithms that keep a global state, it is a common pattern to
1. update the current state to its next step,
2. recursively search for solutions, and
3. roll back the state to the previous step.
To implement such pattern as a monadic program, one might come up with something like the code below:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{search}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{next}} advances the state, \ensuremath{\Varid{prev}} undoes the modification of \ensuremath{\Varid{next}}
(\ensuremath{\Varid{prev}\mathbin{\cdot}\Varid{next}\mathrel{=}\Varid{id}}), and \ensuremath{\Varid{modify}} and \ensuremath{\Varid{modReturn}} are defined by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{modify}\;\Varid{f}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{put}\mathbin{\cdot}\Varid{f})~~,{}\<[E]%
\\
\>[B]{}\Varid{modReturn}\;\Varid{f}\;\Varid{v}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{modify}\;\Varid{f}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{v}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Let the initial state be \ensuremath{\Varid{st}} and assume that \ensuremath{\Varid{search}} found three choices \ensuremath{\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}\mathbin{\talloblong}\Varid{m}_{3}}. The intention is that all of \ensuremath{\Varid{m}_{1}}, \ensuremath{\Varid{m}_{2}}, and \ensuremath{\Varid{m}_{3}} start running with state \ensuremath{\Varid{next}\;\Varid{st}}, and the state is restored to \ensuremath{\Varid{prev}\;(\Varid{next}\;\Varid{st})\mathrel{=}\Varid{st}} afterwards. By \eqref{eq:bind-mplus-dist}, however,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}(\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}\mathbin{\talloblong}\Varid{m}_{3})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}({}\<[22]%
\>[22]{}(\Varid{m}_{1}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev})\mathbin{\talloblong}{}\<[E]%
\\
\>[22]{}(\Varid{m}_{2}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev})\mathbin{\talloblong}{}\<[E]%
\\
\>[22]{}(\Varid{m}_{3}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev}))~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
which, with a global state, means that \ensuremath{\Varid{m}_{2}} starts with state \ensuremath{\Varid{st}}, after which the state is rolled back too early to \ensuremath{\Varid{prev}\;\Varid{st}}. The computation \ensuremath{\Varid{m}_{3}} starts with \ensuremath{\Varid{prev}\;\Varid{st}}, after which the state is rolled too far to \ensuremath{\Varid{prev}\;(\Varid{prev}\;\Varid{st})}.

In fact, one cannot guarantee that \ensuremath{\Varid{modReturn}\;\Varid{prev}} is always executed --- if \ensuremath{\Varid{search}} fails, we get \ensuremath{\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{search}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev}} \ensuremath{\mathrel{=}\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{modReturn}\;\Varid{prev}\mathrel{=}\Varid{modify}\;\Varid{next}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset}. Thus the state is advanced to \ensuremath{\Varid{next}\;\Varid{st}}, but not rolled back to \ensuremath{\Varid{st}}.

We need a way to say that ``\ensuremath{\Varid{modify}\;\Varid{next}} and \ensuremath{\Varid{modReturn}\;\Varid{prev}} are run exactly once, respectively before and after all non-deterministic branches in \ensuremath{\Varid{solve}}.'' Fortunately, we have discovered a curious technique. Define
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{side}\mathbin{::}\Conid{N}\in\epsilon\Rightarrow \Conid{M}_{\epsilon}\;\Varid{a}\to \Conid{M}_{\epsilon}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{side}\;\Varid{m}\mathrel{=}\Varid{m}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Since non-deterministic branches are executed sequentially, the program
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{side}\;(\Varid{modify}\;\Varid{next})\mathbin{\talloblong}\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}\mathbin{\talloblong}\Varid{m}_{3}\mathbin{\talloblong}\Varid{side}\;(\Varid{modify}\;\Varid{prev}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
executes \ensuremath{\Varid{modify}\;\Varid{next}} and \ensuremath{\Varid{modify}\;\Varid{prev}} once, respectively before and after all the non-deterministic branches, even if they fail.
Note that \ensuremath{\Varid{side}\;\Varid{m}} does not generate a result.
Its presence is merely for the side-effect of \ensuremath{\Varid{m}}, hence the name.
%Note also that the type of |side m| need not be the same as that of |m|.

The reader might wonder: now that we are using \ensuremath{(\mathbin{\talloblong})} as a sequencing operator, does it simply coincide with \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}})}?
Recall that we still have left-distributivity \eqref{eq:bind-mplus-dist} and, therefore,
\ensuremath{(\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{n}} equals \ensuremath{(\Varid{m}_{1}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{n})\mathbin{\talloblong}(\Varid{m}_{2}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{n})}.
That is, \ensuremath{(\mathbin{\talloblong})} acts as ``insertion points'', where future code followed by \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}})} can be inserted into!
This is certainly a dangerous feature, whose undisciplined use can lead to chaos.
However, we will exploit this feature and develop a safer programming pattern in the next section.

\subsection{State-Restoring Operations}
\label{subsec:state-restoring-ops}

The discussion above suggests that one can implement backtracking, in a global-state setting, by using \ensuremath{(\talloblong)} and \ensuremath{\Varid{side}} appropriately.
We can even go a bit further by defining the following variations of \ensuremath{\Varid{put}},
which restores the original state when it is backtracked over:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{put}_{\scaleobj{0.7}{\sf R}}\mathbin{::}\{\mskip1.5mu \Conid{S}\;\Varid{s},\Conid{N}\mskip1.5mu\}\mathbin{\subseteq}\epsilon\Rightarrow \Varid{s}\to \Conid{M}_{\epsilon}\;(){}\<[E]%
\\
\>[B]{}\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathrel{=}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}_{0}\to \Varid{put}\;\Varid{s}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}_{0})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{figure}
  \centering
  \includegraphics[scale=0.7]{sections/putR}
  \caption{Illustration of state-restoring put}
  \label{fig:putR}
\end{figure}


To help build understanding for \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}},
Figure~\ref{fig:putR} shows the flow of execution for the expression
\ensuremath{(\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{t}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{ret}\;\Varid{x})\mathbin{\talloblong}\Varid{ret}\;\Varid{y}}. Initially, the state is \ensuremath{\Varid{s}}; it gets
modified to \ensuremath{\Varid{t}} at the \ensuremath{\Varid{put}\;\Varid{t}} node after which the value \ensuremath{\Varid{x}} is output
with the working state \ensuremath{\Varid{t}}.
Then, we backtrack (since we're using global-state semantics, the state
modification caused by \ensuremath{\Varid{put}\;\Varid{t}} is not reversed), arriving at \ensuremath{\Varid{put}\;\Varid{s}}, which
resets the state to \ensuremath{\Varid{s}}, immediately fails, and backtracks to the right
branch of the topmost \ensuremath{(\talloblong)}. There the value \ensuremath{\Varid{y}} is output with working
state \ensuremath{\Varid{s}}.

For some further intuition about \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, consider \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}} where \ensuremath{\Varid{comp}} is some arbitrary computation:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[7]%
\>[7]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}_{0}\to \Varid{put}\;\Varid{s}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}_{0}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}{}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  monad law, left-distributivity \eqref{eq:bind-mplus-dist}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}_{0}\to (\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp})\mathbin{\talloblong}(\Varid{side}\;(\Varid{put}\;\Varid{s}_{0})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}){}\<[E]%
\\
\>[B]{}\mathbin{=}{}\<[9]%
\>[9]{}\mbox{\commentbegin  by \eqref{eq:bind-mzero-zero}, \ensuremath{\emptyset\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}\mathrel{=}\emptyset}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}_{0}\to (\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp})\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}_{0})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Thanks to left-distributivity \eqref{eq:bind-mplus-dist}, \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp})} is promoted into \ensuremath{(\talloblong)}.
Furthermore, the \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp})} after \ensuremath{\Varid{side}\;(\Varid{put}\;\Varid{s}_{0})} is discarded by
\eqref{eq:bind-mzero-zero}.
In words, \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{comp}} saves the current state, computes \ensuremath{\Varid{comp}} using state \ensuremath{\Varid{s}}, and restores the saved state!
The subscript \ensuremath{\Conid{R}} stands for ``restore.''
Note also that \ensuremath{(\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m}_{1})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m}_{2})\mathrel{=}\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}(\Varid{m}_{1}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m}_{2})} --- the state restoration happens in the end.

The behaviour of \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, however, is still rather tricky. It is instructive comparing
\begin{enumerate}[label=(\alph*)]
\item \ensuremath{\Varid{return}\;\Varid{x}},  \label{ex:putR-pitfalls-1}
\item \ensuremath{\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}}, and \label{ex:putR-pitfalls-2}
\item \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}}. \label{ex:putR-pitfalls-3}
\end{enumerate}
When run in initial state \ensuremath{\Varid{s}_{0}}, they all yield \ensuremath{\Varid{x}} as the result.
The final states after running \ref{ex:putR-pitfalls-1}, \ref{ex:putR-pitfalls-2} and \ref{ex:putR-pitfalls-3} are \ensuremath{\Varid{s}_{0}}, \ensuremath{\Varid{s}} and \ensuremath{\Varid{s}_{0}}, respectively.
However, \ref{ex:putR-pitfalls-3} does {\em not} behave identically to \ref{ex:putR-pitfalls-1} in all contexts!
For example, in the context \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{get})}, we can tell them apart:
\ensuremath{\Varid{return}\;\Varid{x}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{get}} returns \ensuremath{\Varid{s}_{0}}, while \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{get}} returns \ensuremath{\Varid{s}}, even though the program yields final state \ensuremath{\Varid{s}_{0}}.

We wish that \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, when run with a global state, satisfies laws \eqref{eq:put-put} through \eqref{eq:mzero-bind-zero} ---
the state laws and the \emph{local} state laws.
If so, one could take a program written for a local state monad, replace all occurrences of \ensuremath{\Varid{put}} by \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, and run the program with a global state.
Unfortunately this is not the case: \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}} does satisfy \ensuremath{\Varid{put}}-\ensuremath{\Varid{put}}~\eqref{eq:put-put} and \ensuremath{\Varid{put}}-\ensuremath{\Varid{get}}~\eqref{eq:put-get}, but \ensuremath{\Varid{get}}-\ensuremath{\Varid{put}}~\eqref{eq:get-put} fails ---
\ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{put}_{\scaleobj{0.7}{\sf R}}} and \ensuremath{\Varid{return}\;()} can be
told apart by some contexts, for example \ensuremath{(\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t})}.
To see that, we calculate:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}%
\column{BE}{@{}l@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{put}_{\scaleobj{0.7}{\sf R}})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\mathrel{=}{}\<[BE]%
\>[4]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}\to \Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}_{0}\to \Varid{put}\;\Varid{s}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}_{0}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\mathrel{=}{}\<[BE]%
\>[5]{}\mbox{\commentbegin  \ensuremath{\Varid{get}}-\ensuremath{\Varid{get}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}\to \Varid{put}\;\Varid{s}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\mathrel{=}{}\<[BE]%
\>[5]{}\mbox{\commentbegin  monad laws, left-distributivity  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}\to (\Varid{put}\;\Varid{s}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t})\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\mathrel{=}{}\<[BE]%
\>[5]{}\mbox{\commentbegin  \ensuremath{\Varid{put}}-\ensuremath{\Varid{put}}  \commentend}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}\to \Varid{put}\;\Varid{t}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Meanwhile, \ensuremath{\Varid{return}\;()\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{put}\;\Varid{t}\mathrel{=}\Varid{put}\;\Varid{t}}, which does not behave in the same way as \ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{s}\to \Varid{put}\;\Varid{t}\mathbin{\talloblong}\Varid{side}\;(\Varid{put}\;\Varid{s})} when $s \neq t$.

In a global-state setting, the left-distributivity law \eqref{eq:bind-mplus-dist} makes it tricky to reason about combinations of \ensuremath{(\talloblong)} and \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})} operators.
Suppose we have a program \ensuremath{(\Varid{m}\mathbin{\talloblong}\Varid{n})}, and we construct an extended program by binding a continuation \ensuremath{\Varid{f}} to it such that we get \ensuremath{(\Varid{m}\mathbin{\talloblong}\Varid{n})\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}} (where \ensuremath{\Varid{f}} might modify the state).
Under global-state semantics, the evaluation of the right branch is influenced by the state modifications performed by evaluating the left branch.
So by \eqref{eq:bind-mplus-dist}, this means that when we get to evaluating the \ensuremath{\Varid{n}} subprogram in the extended program, it will do so with a different initial state (the one obtained after running \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}}) compaired against the initial state in the original program (the one obtained by running \ensuremath{\Varid{m}}).
In other words, placing our program in a different context changed the meaning of one of its subprograms.
So it is difficult to reason about programs compositionally in this setting --- some properties hold only when we take the entire program into consideration.

It turns out that all properties we need do hold, provided that {\em all} occurrences of \ensuremath{\Varid{put}} are replaced by \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}} --- problematic contexts such as \ensuremath{\Varid{put}\;\Varid{t}} above are thus ruled out.
However, that ``all \ensuremath{\Varid{put}} are replaced by \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}'' is a global property, and to properly talk about it we have to formally define contexts, which is what we will do in Section~\ref{sec:ctxt-trans}.

\section{Laws and Translation for Global State Monad}
\label{sec:ctxt-trans}

In this section we give a more formal treatment of non-deterministic global state monad.
We propose laws such a monad should satisfy --- to the best of our knowledge, we are the first to propose these laws.
The laws turn out to be rather intricate.
To make sure that there exists a model, an implementation is proposed in the appendix, and it is verified in Coq that the laws and some additional theorems are satisfied.

The ultimate goal, however, is to show the following property:
given a program written for a local-state monad,
if we replace all occurrences of \ensuremath{\Varid{put}} by \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, the resulting
program yields the same result when run with a global-state monad.
This allows us to painlessly port our previous algorithm to work
with a global state.
To show this we first introduce a syntax for nondeterministic and stateful
monadic programs and contexts.
Then we imbue these programs with global-state semantics.
Finally we define the function that performs the translation just described, and prove that this translation is correct.



\subsection{Programs and Contexts}
\begin{figure}
\begin{mdframed}
\centering
\scriptsize
\subfloat[]{
\begin{minipage}{0.5\textwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Prog}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Return}{}\<[11]%
\>[11]{}\mathbin{::}\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\emptyset{}\<[11]%
\>[11]{}\mathbin{::}\Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\talloblong){}\<[11]%
\>[11]{}\mathbin{::}\Conid{Prog}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Get}{}\<[11]%
\>[11]{}\mathbin{::}(\Conid{S}\to \Conid{Prog}\;\Varid{a})\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Put}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{S}\to \Conid{Prog}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\subfloat[]{
  \begin{minipage}{0.5\textwidth}
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\mathbf{data}\;\Conid{Env}\;(\Varid{l}\mathbin{::}[\mskip1.5mu \mathbin{*}\mskip1.5mu])\;\mathbf{where}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Nil}{}\<[14]%
\>[14]{}\mathbin{::}\Conid{Env}\;`[]{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Cons}\mathbin{::}\Varid{a}\to \Conid{Env}\;\Varid{l}\to \Conid{Env}\;(\Varid{a}\mathbin{:}\Varid{l}){}\<[E]%
\\[\blanklineskip]%
\>[7]{}\mathbf{type}\;\Conid{OProg}\;\Varid{e}\;\Varid{a}\mathrel{=}\Conid{Env}\;\Varid{e}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \end{minipage}
}
\quad
\subfloat[]{
  \begin{minipage}{0.5\textwidth}
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathbf{data}\;\Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}\;\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\square{}\<[15]%
\>[15]{}\mathbin{::}\Conid{Ctx}\;\Varid{e}\;\Varid{a}\;\Varid{e}\;\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{COr1}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}\to \Conid{OProg}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[15]{}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{COr2}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{OProg}\;\Varid{e}_{2}\;\Varid{b}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[15]{}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{CPut}{}\<[15]%
\>[15]{}\mathbin{::}(\Conid{Env}\;\Varid{e}_{2}\to \Conid{S})\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[15]{}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{CGet}{}\<[15]%
\>[15]{}\mathbin{::}(\Conid{S}\to \Conid{Bool})\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;(\Conid{S}\mathbin{:}\Varid{e}_{2})\;\Varid{b}{}\<[E]%
\\
\>[15]{}\to (\Conid{S}\to \Conid{OProg}\;\Varid{e}_{2}\;\Varid{b})\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{CBind1}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}\to (\Varid{b}\to \Conid{OProg}\;\Varid{e}_{2}\;\Varid{c}){}\<[E]%
\\
\>[15]{}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{c}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{CBind2}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{OProg}\;\Varid{e}_{2}\;\Varid{a}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{b}\;(\Varid{a}\mathbin{:}\Varid{e}_{2})\;\Varid{c}{}\<[E]%
\\
\>[15]{}\to \Conid{Ctx}\;\Varid{e}_{1}\;\Varid{b}\;\Varid{e}_{2}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \end{minipage}
}
\subfloat[]{
  \begin{minipage}{0.5\textwidth}
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}c<{\hspost}@{}}%
\column{7E}{@{}l@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{run}{}\<[7E]%
\>[14]{}\mathbin{::}\Conid{Prog}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}{}\<[7E]%
\>[14]{}\mathbin{::}\Varid{a}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}{}\<[7E]%
\>[14]{}\mathbin{::}\Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}{}\<[7E]%
\>[14]{}\mathbin{::}\Conid{Dom}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}{}\<[7E]%
\>[14]{}\mathbin{::}(\Conid{S}\to \Conid{Dom}\;\Varid{a})\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}{}\<[7E]%
\>[14]{}\mathbin{::}\Conid{S}\to \Conid{Dom}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \end{minipage}
}
\quad
\end{mdframed}
\caption{(a) Syntax for programs. (b) Environments and open programs. (c) Syntax
  for contexts. (d) Semantic domain.}
\label{fig:context-semantics}
\end{figure}
In the previous sections we have been mixing syntax and semantics,
which we avoid in this section by defining the program syntax as a free monad.
This way we avoid the need for a type-level distinction between programs
with local-state semantics and programs with global-state semantics.
Figure~\ref{fig:context-semantics}(a) defines a syntax for
nondeterministic, stateful, closed programs \ensuremath{\Conid{Prog}}, where
the \ensuremath{\Conid{Get}} and \ensuremath{\Conid{Put}} constructors take continuations as arguments, and
the \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})} operator is defined as follows:
\begin{samepage}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})\mathbin{::}\Conid{Prog}\;\Varid{a}\to (\Varid{a}\to \Conid{Prog}\;\Varid{b})\to \Conid{Prog}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\Conid{Return}\;\Varid{x}{}\<[18]%
\>[18]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathrel{=}\Varid{f}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\emptyset{}\<[18]%
\>[18]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathrel{=}\emptyset{}\<[E]%
\\
\>[3]{}(\Varid{m}\mathbin{\talloblong}\Varid{n}){}\<[18]%
\>[18]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathrel{=}(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f})\mathbin{\talloblong}(\Varid{n}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}){}\<[E]%
\\
\>[3]{}\Conid{Get}\;\Varid{k}{}\<[18]%
\>[18]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathrel{=}\Conid{Get}\;(\lambda \Varid{s}\to \Varid{k}\;\Varid{s}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}){}\<[E]%
\\
\>[3]{}\Conid{Put}\;\Varid{s}\;\Varid{m}{}\<[18]%
\>[18]{}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}\mathrel{=}\Conid{Put}\;\Varid{s}\;(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{k})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}%
One can see that \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})} is defined as a purely syntactical manipulation, and
its definition has laws \eqref{eq:bind-mplus-dist} and
\eqref{eq:bind-mzero-zero} built-in.

The meaning of such a monadic program is determined by a semantic domain of our
choosing, which we denote with \ensuremath{\Conid{Dom}}, and its corresponding
domain operators \ensuremath{\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}}, \ensuremath{\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}}, \ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}}, \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}} and \ensuremath{(\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}})}
(see figure~\ref{fig:context-semantics}(d)).
The \ensuremath{\Varid{run}\mathbin{::}\Conid{Prog}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}} function ``runs'' a program \ensuremath{\Conid{Prog}\;\Varid{a}} into a value
in the semantic domain \ensuremath{\Conid{Dom}\;\Varid{a}}:
\begin{samepage}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{run}\;(\Conid{Return}\;\Varid{x}){}\<[22]%
\>[22]{}\mathrel{=}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{run}\;\emptyset{}\<[22]%
\>[22]{}\mathrel{=}\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}{}\<[E]%
\\
\>[B]{}\Varid{run}\;(\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}){}\<[22]%
\>[22]{}\mathrel{=}\Varid{run}\;\Varid{m}_{1}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{run}\;\Varid{m}_{2}{}\<[E]%
\\
\>[B]{}\Varid{run}\;(\Conid{Get}\;\Varid{k}){}\<[22]%
\>[22]{}\mathrel{=}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \Varid{run}\;(\Varid{k}\;\Varid{s})){}\<[E]%
\\
\>[B]{}\Varid{run}\;(\Conid{Put}\;\Varid{s}\;\Varid{m}){}\<[22]%
\>[22]{}\mathrel{=}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\Varid{run}\;\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}%
Note that no \ensuremath{\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}}} operator is required to define \ensuremath{\Varid{run}};
in other words, \ensuremath{\Conid{Dom}} need not be a monad.
In fact, as we will see later, we will choose our implementation in such a way
that there does not exist a bind operator for \ensuremath{\Varid{run}}.

\subsection{Modeling Global State Semantics}
\label{sec:model-global-state-sem}
We impose the laws upon \ensuremath{\Conid{Dom}} and the domain operators to ensure the semantics of a
non-backtracking (global-state),
nondeterministic, stateful computation for our programs.
Naturally, we need laws analogous to the state laws and nondeterminism laws to
hold for our semantic domain.
As it is not required that a bind operator
(\ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})\mathbin{::}\Conid{Dom}\;\Varid{a}\to (\Varid{a}\to \Conid{Dom}\;\Varid{b})\to \Conid{Dom}\;\Varid{b}}) can be defined for the semantic
domain (and we will later argue that it \emph{cannot} be defined for the domain,
given the laws we impose on it), the state laws
(\eqref{eq:put-put} through \eqref{eq:get-get})
must be reformulated to fit the continuation-passing style of the semantic domain
operators.
\begin{align}
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{t}\;\Varid{p})} &= \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{t}\;\Varid{p}} \mbox{~~,} \label{eq:put-put-g-d} \\
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\Varid{k})} &= \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\Varid{k}\;\Varid{s})} \mbox{~~,} \label{eq:put-get-g-d} \\
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\Varid{m})} &= \ensuremath{\Varid{m}} \mbox{~~,} \label{eq:get-put-g-d} \\
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{t}\to \Varid{k}\;\Varid{s}\;\Varid{t}))} &= \ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \Varid{k}\;\Varid{s}\;\Varid{s})} \mbox{~~.} \label{eq:get-get-g-d}
\end{align}
As for the nondeterminism laws
(\eqref{eq:mplus-assoc}, \eqref{eq:mzero-mplus}, \eqref{eq:bind-mplus-dist},
\eqref{eq:bind-mzero-zero}),
we can simply omit the ones that mention at the semantic level \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})}
as these are proven at the syntactic level: their proof follows immediately
from \ensuremath{\Conid{Prog}}'s definition of \ensuremath{(\mathrel{\hstretch{0.7}{>\!\!>\!\!=}})}.
\begin{align}
  &\ensuremath{(\Varid{m}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{n})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{p}} = \ensuremath{\Varid{m}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}(\Varid{n}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{p})} \mbox{~~,} \\
  &\ensuremath{\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{m}} = \ensuremath{\Varid{m}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}} = \ensuremath{\Varid{m}} \mbox{~~.}
\end{align}

We also reformulate the global-state law~\eqref{eq:put-or}:
\begin{align}
\ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\Varid{p}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{q}}        &= \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\Varid{p}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{q})} \mbox{~~.}\label{eq:put-or-g-d}
\end{align}
%In Section~\ref{sec:laws-global-state} we also mentioned that a law should exist
%which mandates a limited form of right-distribitivity which only holds on a
%global level.
%The continuation-passing style of our semantic domain operators allows us to
%express a weaker version of this global property (which suffices for our goals)
%as follows:
It turns out that, apart from the {\bf put-or} law,
our proofs require certain additional properties regarding commutativity and
distributivity which we introduce here:
\begin{align}
\begin{split}
\ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;(\Varid{t}\;\Varid{s})\;\Varid{p}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;(\Varid{u}\;\Varid{s})\;\Varid{q}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle})} = \\
~~~~~~\ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;(\Varid{u}\;\Varid{s})\;\Varid{q}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;(\Varid{t}\;\Varid{s})\;\Varid{p}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle})} \mbox {~~,}
\end{split} \label{eq:put-or-comm-g-d} \\
& \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{p})} = \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\Varid{p}} \mbox{~~.}\label{eq:put-ret-or-g-d}
\end{align}
These laws are not considered general ``global state'' laws, because it is
possible to define reasonable implementations of global state semantics that
violate these laws, and because they are not exclusive to global state
semantics.

The \ensuremath{\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}} operator is not, in general, commutative in a global state setting.
However, we will require that the order in which results are computed does not
matter.
Furthermore we require that the implementation is agnostic with repect to the
order of \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}} operations as long as the exact same results are computed with
the exact same state at the time of their computation.
These properties are enforced by law~\eqref{eq:put-or-comm-g-d}.
Implementations that present the results as an ordered list violate this law,
as are implementations that record the order of proper state changes.

In global-state semantics, \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}} operations cannot, in general,
distribute over \ensuremath{\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}}.
However, an implementation may permit distributivity if certain conditions are
met.
Law~\eqref{eq:put-ret-or-g-d} states that a \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}} operation distributes over a
nondeterministic choice if the left branch of that choice simply returns a
value.
An example of an implementation that violates this law would be one that
applies a given function \ensuremath{\Varid{f}\mathbin{::}\Varid{s}\to \Varid{s}} to the state after each return.
Such an implementation would conform to an alternative law
\ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{q})\mathrel{=}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;(\Varid{f}\;\Varid{x})\;\Varid{q}}.
Law~\eqref{eq:put-ret-or-g-d} only holds if the implementation of \ensuremath{\Conid{Dom}} does not
permit the definition
of a bind operator \ensuremath{(\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}})\mathbin{::}\Conid{Dom}\;\Varid{a}\to (\Varid{a}\to \Conid{Dom}\;\Varid{b})\to \Conid{Dom}\;\Varid{b}}.
Consider for instance the following program:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle})\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}}\lambda \Varid{z}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{z})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If \eqref{eq:put-ret-or-g-d} holds, this program should be equal to
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}))\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}}\lambda \Varid{z}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{z})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
However, Figure~\ref{fig:put-ret-or-vs-bind} proves that the first program can
be reduced to \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{y})},
whereas the second program is equal to
\ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x})},
which clearly does not always have the same result.
\begin{figure}
  \centering
  \tiny
  \subfloat[]{
  \begin{minipage}{0.5\textwidth}
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle})\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}}\lambda \Varid{z}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{z}){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  definition of \ensuremath{(\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}})}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{s}))){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-or-g-d} and \eqref{eq:put-put-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{s}))){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-ret-or-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}{}\<[29]%
\>[29]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{s}))){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-get-g-d} and \eqref{eq:put-put-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{y}){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-ret-or-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \end{minipage}
  }
  \subfloat[]{
  \begin{minipage}{0.5\textwidth}
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle})){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}}\lambda \Varid{z}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{z}){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  definition of \ensuremath{(\mathbin{\scaleobj{0.8}{\langle\hstretch{0.7}{>\!\!>\!\!=}\rangle}})}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;(\lambda \Varid{s}\to \scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{s}))){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-put-g-d} and \eqref{eq:put-get-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{x}\;(\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x})){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-put-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w})\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x}){}\<[E]%
\\
\>[7]{}\mathbin{=}\mbox{\commentbegin  by \eqref{eq:put-ret-or-g-d}  \commentend}{}\<[E]%
\\
\>[7]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{y}\;(\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{w}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \end{minipage}
  }
  \caption{Proof that law~\eqref{eq:put-ret-or-g-d} implies that a bind operator
    cannot exist for the semantic domain.}
  \label{fig:put-ret-or-vs-bind}
\end{figure}

% put x (return w || q) >>= \z -> put y (return z)
%put x (return w >>= \z -> put y (return z) || get return >>= \z -> put y (return z))
%put x (put y (return w)
%       ||
%       get (\s -> put y (return s))
%      )
%  [put-or]
%put x (put y (return w || get (\s -> put y (return s))))
%  [put-put]
%put y (return w || get (\s -> put y (return s)))
%  [put-ret-or]
%put y (return w) || put y (get \s -> put y (return s))
%  [put-get]
%put y (return w) || put y (put y (return y))
%  [put-put]
%put y (return w) || put y (return y)
%  [put-ret-or]
%put y (return w || return y)
%-> ([(w,y)), (y,y)],y)
%################################################################################
%(put x (return w) || put x (get return))
%>>=
%\z -> put y (return z)
%  [def >>=]
%put x (return w) >>= \z -> put y (return z)
%||
%put x (get return) >>= \z -> put y (return z)
%  [def >>=]
%put x (put y (return w))
%||
%put x (get (\s -> put y (return s)))
%  [put-put, put-get]
%put y (return w)
%||
%put x (put y (return x))
%  [put-put]
%put y (return w)
%||
%put y (return x)
%  [put-or]
%put y (return w || put y return x)
%  [put-ret-or, put-put]
%put y (return w) || put y (return x)
%  [put-ret-or]
%put y (return w || return x)

It is worth remarking that, even if we don't impose law~\eqref{eq:put-or-comm-g-d},
this requirement disqualifies the most
straightforward candidate for the semantic domain, \ensuremath{\Conid{ListT}\;(\Conid{State}\;\Varid{s})}, as a
bind operator can be defined for it.

In Appendix~\ref{sec:GSMonad} we present an implementation of \ensuremath{\Conid{Dom}} and its
operators that satisfies all the laws in this section, for which we provide
\emph{machine-verified proofs}, and which does not permit
the implementation of a sensible bind operator.

\subsection{Contextual Equivalence}
\label{subsec:contextual-equivalence}
With our semantic domain sufficiently specified, we can prove analogous
properties for programs interpreted through this domain.
We must take care in how we reformulate these properties however.
It is certainly not sufficient to merely copy the laws as formulated for the
semantic domain, substituting \ensuremath{\Conid{Prog}} data constructors for semantic domain
operators as needed; we must keep in mind that a term in \ensuremath{\Conid{Prog}\;\Varid{a}} describes a
syntactical structure without ascribing meaning to it.
For example, one cannot simply assert that \ensuremath{\Conid{Put}\;\Varid{x}\;(\Conid{Put}\;\Varid{y}\;\Varid{p})} is \emph{equal} to
\ensuremath{\Conid{Put}\;\Varid{y}\;\Varid{p}}, because although these two programs have the same semantics, they
are not structurally identical.
It is clear that we must define a notion of ``semantical equivalence'' between
programs.
We can map the syntactical structures in \ensuremath{\Conid{Prog}\;\Varid{a}} onto the semantic domain
\ensuremath{\Conid{Dom}\;\Varid{a}} using \ensuremath{\Varid{run}} to achieve that.
Yet wrapping both sides of an equation in \ensuremath{\Varid{run}} applications
is not enough as such statements only apply at the top-level of a program.
For instance, while \ensuremath{\Varid{run}\;(\Conid{Put}\;\Varid{x}\;(\Conid{Put}\;\Varid{y}\;\Varid{p}))\mathrel{=}\Varid{run}\;(\Conid{Put}\;\Varid{y}\;\Varid{p})} is a correct statement,
we cannot prove
\ensuremath{\Varid{run}\;(\Conid{Return}\;\Varid{w}\mathbin{\talloblong}\Conid{Put}\;\Varid{x}\;(\Conid{Put}\;\Varid{y}\;\Varid{p}))\mathrel{=}\Varid{run}\;(\Conid{Return}\;\Varid{w}\mathbin{\talloblong}\Conid{Put}\;\Varid{y}\;\Varid{p})}
from such a law.

So the concept of semantical equivalence in itself is not sufficient; we require
a notion of ``contextual semantic equivalence'' of programs which allows us to
formulate properties about semantical equivalence which hold in any surrounding
context.
Figure~\ref{fig:context-semantics}(c) provides the definition for single-hole
contexts \ensuremath{\Conid{Ctx}}.
A context \ensuremath{\Conid{C}} of type \ensuremath{\Conid{Ctx}\;\Varid{e}_{1}\;\Varid{a}\;\Varid{e}_{2}\;\Varid{b}} can be interpreted as a function that, given a
program that returns a value of type \ensuremath{\Varid{a}} under environment \ensuremath{\Varid{e}_{1}} (in other words:
the type and environment of the hole), produces a program that returns a value
of type \ensuremath{\Varid{b}} under environment \ensuremath{\Varid{e}_{2}} (the type and environment of the whole program).
Filling the hole with \ensuremath{\Varid{p}} is denoted by \ensuremath{\Conid{C}\lbrack\Varid{p}\rbrack}.
The type of environments, \ensuremath{\Conid{Env}} is defined using heterogeneous lists
(Figure~\ref{fig:context-semantics}(b)).
When we consider the notion of programs in contexts, we must take into account
that these contexts may introduce variables which are referenced by the program.
The \ensuremath{\Conid{Prog}} datatype however represents only closed programs.
Figure~\ref{fig:context-semantics}(b) introduces the \ensuremath{\Conid{OProg}} type to represent
``open'' programs, and the \ensuremath{\Conid{Env}} type to represent environments.
\ensuremath{\Conid{OProg}\;\Varid{e}\;\Varid{a}} is defined as the type of functions that construct a \emph{closed}
program of type \ensuremath{\Conid{Prog}\;\Varid{a}}, given an environment of type \ensuremath{\Conid{Env}\;\Varid{e}}.
Environments, in turn, are defined as heterogeneous lists.
We also define a function for mapping open programs onto the semantic domain.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{orun}\mathbin{::}\Conid{OProg}\;\Varid{e}\;\Varid{a}\to \Conid{Env}\;\Varid{e}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{orun}\;\Varid{p}\;\Varid{env}\mathrel{=}\Varid{run}\;(\Varid{p}\;\Varid{env})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can then assert that two programs are contextually equivalent if, for
\emph{any} context, running both programs wrapped in that context will
yield the same result:
\newcommand{\CEq}{=_\mathtt{GS}}
\begin{align*}
  \ensuremath{\Varid{m}_{1}} \CEq \ensuremath{\Varid{m}_{2}} \triangleq \forall C. \ensuremath{\Varid{orun}\;(\Conid{C}\lbrack\Varid{m}_{1}\rbrack)} = \ensuremath{\Varid{orun}\;(\Conid{C}\lbrack\Varid{m}_{2}\rbrack)} \mbox{~~.}
\end{align*}

We can then straightforwardly formulate variants of the state laws, the
nondeterminism laws and the \ensuremath{\Varid{put}}-\ensuremath{\Varid{or}} law for this global state monad as
lemmas. For example, we reformulate law~\eqref{eq:put-put-g-d} as
\begin{align*}
  \ensuremath{\Conid{Put}\;\Varid{s}\;(\Conid{Put}\;\Varid{t}\;\Varid{p})} &\CEq \ensuremath{\Conid{Put}\;\Varid{t}\;\Varid{p}} \mbox{~~.}
\end{align*}
Proofs for the state laws, the nondeterminism laws and the \ensuremath{\Varid{put}}-\ensuremath{\Varid{or}} law then
easily follow from the analogous semantic domain laws. The formulation of a
\ensuremath{\Varid{put}}-\ensuremath{\Varid{ret}}-\ensuremath{\Varid{or}} law-like property \eqref{eq:put-ret-or-g-d} requires somewhat
more care: because there exists a bind operator for \ensuremath{\Conid{Prog}}, we must stipulate
that it does not hold in arbitrary contexts:
\begin{align}
\ensuremath{\Varid{run}\;(\Conid{Put}\;\Varid{s}\;(\Conid{Return}\;\Varid{x}\mathbin{\talloblong}\Varid{p}))} = \ensuremath{\Varid{run}\;(\Conid{Put}\;\Varid{s}\;(\Conid{Return}\;\Varid{x})\mathbin{\talloblong}\Conid{Put}\;\Varid{s}\;\Varid{p})} \label{eq:put-ret-or-g} \mbox{~~.} \checkmark
\end{align}
The proof of this statement has been machine-verified in Coq.
We annotate theorems which have been verified in Coq with a $\checkmark$.

\subsection{Simulating Local-State Semantics}

We simulate local-state semantics by replacing each occurrence of \ensuremath{\Conid{Put}} by a
variant that restores the state, as described in Section~\ref{subsec:state-restoring-ops}. This transformation is implemented by the
function \ensuremath{\Varid{trans}} for closed programs, and \ensuremath{\Varid{otrans}} for open programs:
\begin{samepage}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{trans}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{Prog}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{trans}\;(\Conid{Return}\;\Varid{x}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{Return}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{trans}\;(\Varid{p}\mathbin{\talloblong}\Varid{q}){}\<[24]%
\>[24]{}\mathrel{=}\Varid{trans}\;\Varid{p}\mathbin{\talloblong}\Varid{trans}\;\Varid{q}{}\<[E]%
\\
\>[3]{}\Varid{trans}\;\emptyset{}\<[24]%
\>[24]{}\mathrel{=}\emptyset{}\<[E]%
\\
\>[3]{}\Varid{trans}\;(\Conid{Get}\;\Varid{p}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{Get}\;(\lambda \Varid{s}\to \Varid{trans}\;(\Varid{p}\;\Varid{s})){}\<[E]%
\\
\>[3]{}\Varid{trans}\;(\Conid{Put}\;\Varid{s}\;\Varid{p}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{Get}\;(\lambda \Varid{s'}\to \Conid{Put}\;\Varid{s}\;(\Varid{trans}\;\Varid{p})\mathbin{\talloblong}\Conid{Put}\;\Varid{s'}\;\emptyset)~~,{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{otrans}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{OProg}\;\Varid{e}\;\Varid{a}\to \Conid{OProg}\;\Varid{e}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{otrans}\;\Varid{p}{}\<[24]%
\>[24]{}\mathrel{=}\lambda \Varid{env}\to \Varid{trans}\;(\Varid{p}\;\Varid{env})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}%
We then define the function \ensuremath{\Varid{eval}}, which runs a transformed program (in other
words, it runs a program with local-state semantics).
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eval}\mathbin{::}\Conid{Prog}\;\Varid{a}\to \Conid{Dom}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{eval}\mathrel{=}\Varid{run}\mathbin{\cdot}\Varid{trans}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We show that the transformation works by proving that our free monad equipped
with \ensuremath{\Varid{eval}} is a correct
implementation for a nondeterministic, stateful monad with local-state semantics.
We introduce notation for ``contextual equivalence under simulated backtracking
semantics'':
\newcommand{\CEqLS}{=_\mathtt{LS}}
\begin{align*}
  \ensuremath{\Varid{m}_{1}} \CEqLS \ensuremath{\Varid{m}_{2}} \triangleq \forall C. \ensuremath{\Varid{eval}\;(\Conid{C}\lbrack\Varid{m}_{1}\rbrack)} = \ensuremath{\Varid{eval}\;(\Conid{C}\lbrack\Varid{m}_{2}\rbrack)} \mbox{~~.}
\end{align*}
For example, we formulate the statement that the \ensuremath{\Varid{put}}-\ensuremath{\Varid{put}}
law~\eqref{eq:put-put-g-d} holds for our monad as interpreted by \ensuremath{\Varid{eval}} as
\begin{align*}
  \ensuremath{\Conid{Put}\;\Varid{s}\;(\Conid{Put}\;\Varid{t}\;\Varid{p})} &\CEqLS \ensuremath{\Conid{Put}\;\Varid{t}\;\Varid{p}} \mbox{~~.} \checkmark
\end{align*}
Proofs for the nondeterminism laws follow trivially from the nondeterminism laws
for global state.
The state laws are proven by promoting \ensuremath{\Varid{trans}} inside, then applying
global-state laws.
For the proof of the \ensuremath{\Varid{get}}-\ensuremath{\Varid{put}} law, we require the property that in
global-state semantics, \ensuremath{\Conid{Put}} distributes over \ensuremath{(\mathbin{\talloblong})} if the left branch
has been transformed (in which case the left branch leaves the state unmodified).
This property only holds at the top-level.
\begin{align}
  % put_or_trans
\ensuremath{\Varid{run}\;(\Conid{Put}\;\Varid{x}\;(\Varid{trans}\;\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}))} = \ensuremath{\Varid{run}\;(\Conid{Put}\;\Varid{x}\;(\Varid{trans}\;\Varid{m}_{1})\mathbin{\talloblong}\Conid{Put}\;\Varid{x}\;\Varid{m}_{2})} \label{eq:put-ret-mplus-g}\mbox{~~.} \checkmark
\end{align}
Proof of this lemma depends on law~\eqref{eq:put-ret-or-g-d}.

Finally, we arrive at the core of our proof:
to show that the interaction of state and nondeterminism in this
implementation produces backtracking semantics.
To this end we prove laws analogous to the local state laws
\eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero}
\begin{align}
  \ensuremath{\Varid{m}\mathbin{\hstretch{0.7}{>\!\!>}}\emptyset}                      &\CEqLS \ensuremath{\emptyset} \mbox{~~,} \label{eq:mplus-bind-zero-l} \checkmark \\
  \ensuremath{\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{x}\to \Varid{f}_{1}\;\Varid{x}\mathbin{\talloblong}\Varid{f}_{2}\;\Varid{x})} &\CEqLS \ensuremath{(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{1})\mathbin{\talloblong}(\Varid{m}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{f}_{2})} \mbox{~~.} \checkmark \label{eq:mplus-bind-dist-l}
\end{align}
We provide machine-verified proofs for these theorems.

The proof for~\eqref{eq:mplus-bind-zero-l} follows by straightforward induction.

The inductive proof (with induction on \ensuremath{\Varid{m}}) of law~\eqref{eq:mplus-bind-dist-l}
requires some additional lemmas.

For the case \ensuremath{\Varid{m}\mathrel{=}\Varid{m}_{1}\mathbin{\talloblong}\Varid{m}_{2}}, we require the property that, at the top-level
of a global-state program, \ensuremath{(\talloblong)} is commutative if both its operands are
state-restoring.
Formally:
\begin{align}
  \ensuremath{\Varid{run}\;(\Varid{trans}\;\Varid{p}\mathbin{\talloblong}\Varid{trans}\;\Varid{q})} = \ensuremath{\Varid{run}\;(\Varid{trans}\;\Varid{q}\mathbin{\talloblong}\Varid{trans}\;\Varid{p})}\mbox{~~.} \checkmark
\end{align}
The proof of this property motivated the introduction of
law~\eqref{eq:put-or-comm-g-d}.

The proof for both the \ensuremath{\Varid{m}\mathrel{=}\Conid{Get}\;\Varid{k}} and \ensuremath{\Varid{m}\mathrel{=}\Conid{Put}\;\Varid{s}\;\Varid{m'}} cases requires that \ensuremath{\Conid{Get}}
distributes
over \ensuremath{(\talloblong)} at the top-level of a global-state program if the left branch is
state restoring.
\begin{align}
  % get_or_trans
\ensuremath{\Varid{run}\;(\Conid{Get}\;(\lambda \Varid{s}\to \Varid{trans}\;(\Varid{m}_{1}\;\Varid{s})\mathbin{\talloblong}(\Varid{m}_{2}\;\Varid{s})))} = \\
\ensuremath{\Varid{run}\;(\Conid{Get}\;(\lambda \Varid{s}\to \Varid{trans}\;(\Varid{m}_{1}\;\Varid{s}))\mathbin{\talloblong}\Conid{Get}\;\Varid{m}_{2})} \label{eq:get-ret-mplus-g}\mbox{~~.} \checkmark
\end{align}

And finally, we require that the \ensuremath{\Varid{trans}} function is, semantically speaking,
idempotent, to prove the case \ensuremath{\Varid{m}\mathrel{=}\Conid{Put}\;\Varid{s}\;\Varid{m'}}.
\begin{align}
  % get_or_trans
\ensuremath{\Varid{run}\;(\Varid{trans}\;(\Varid{trans}\;\Varid{p}))\mathrel{=}\Varid{run}\;(\Varid{trans}\;\Varid{p})} \label{eq:run-trans-trans} \mbox{~~.} \checkmark
\end{align}

\noindent

\subsection{Backtracking with a Global State Monad}
There is still one technical detail to to deal with before we deliver a backtracking algorithm that uses a global state.
As mentioned in Section~\ref{sec:chaining}, rather than using \ensuremath{\Varid{put}}, some
algorithms typically use a pair of commands \ensuremath{\Varid{modify}\;\Varid{next}} and \ensuremath{\Varid{modify}\;\Varid{prev}},
with \ensuremath{\Varid{prev}\mathbin{\cdot}\Varid{next}\mathrel{=}\Varid{id}}, to respectively update and roll back the state.
This is especially true when the state is implemented using an array or other data structure that is usually not overwritten in its entirety.
Following a style similar to \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, this can be modelled by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{modify}_{\scaleobj{0.7}{\sf R}}\mathbin{::}\{\mskip1.5mu \Conid{N},\Conid{S}\;\Varid{s}\mskip1.5mu\}\mathbin{\subseteq}\epsilon\to (\Varid{s}\to \Varid{s})\to (\Varid{s}\to \Varid{s})\to \Conid{M}_{\epsilon}\;(){}\<[E]%
\\
\>[3]{}\Varid{modify}_{\scaleobj{0.7}{\sf R}}\;\Varid{next}\;\Varid{prev}\mathrel{=}\Varid{modify}\;\Varid{next}\mathbin{\talloblong}\Varid{side}\;(\Varid{modify}\;\Varid{prev})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Is it safe to use an alternative translation, where the pattern
\ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{s}\to \Varid{put}\;(\Varid{next}\;\Varid{s})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{m})} is not translated into
\ensuremath{\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\lambda \Varid{s}\to \Varid{put}_{\scaleobj{0.7}{\sf R}}\;(\Varid{next}\;\Varid{s})\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{trans}\;\Varid{m})}, but rather into
\ensuremath{\Varid{modify\char95 R}\;\Varid{next}\;\Varid{prev}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{trans}\;\Varid{m}}?
We explore this question by extending our \ensuremath{\Conid{Prog}} syntax with an additional
\ensuremath{\Conid{Modify\char95 R}} construct, thus obtaining a new \ensuremath{\Conid{Prog\char95 m}} syntax:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Prog\char95 m}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\mathbin{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Modify\char95 R}{}\<[13]%
\>[13]{}\mathbin{::}(\Conid{S}\to \Conid{S})\to (\Conid{S}\to \Conid{S})\to \Conid{Prog\char95 m}\;\Varid{a}\to \Conid{Prog\char95 m}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We assume that \ensuremath{\Varid{prev}\mathbin{\cdot}\Varid{next}\mathrel{=}\Varid{id}} for every \ensuremath{\Conid{Modify\char95 R}\;\Varid{next}\;\Varid{prev}\;\Varid{p}} in a \ensuremath{\Conid{Prog\char95 m}\;\Varid{a}} program.

We then define two translation functions from \ensuremath{\Conid{Prog\char95 m}\;\Varid{a}} to \ensuremath{\Conid{Prog}\;\Varid{a}},
which both replace \ensuremath{\Conid{Put}}s with \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}s along the way, like the regular
\ensuremath{\Varid{trans}} function.
The first replaces each \ensuremath{\Conid{Modify\char95 R}} in the program by a direct analogue of the
definition given above, while the second replaces it by
\ensuremath{\Conid{Get}\;(\lambda \Varid{s}\to \Conid{Put}\;(\Varid{next}\;\Varid{s})\;(\Varid{trans}_{\scaleobj{0.7}{2}}\;\Varid{p}))}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{trans}_{\scaleobj{0.7}{1}}\mathbin{::}\Conid{Prog\char95 m}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[4]{}\mathbin{...}{}\<[E]%
\\
\>[4]{}\Varid{trans}_{\scaleobj{0.7}{1}}\;(\Conid{Modify\char95 R}\;\Varid{next}\;\Varid{prev}\;\Varid{p}){}\<[36]%
\>[36]{}\mathrel{=}{}\<[45]%
\>[45]{}\Conid{Get}\;(\lambda \Varid{s}\to \Conid{Put}\;(\Varid{next}\;\Varid{s})\;(\Varid{trans}_{\scaleobj{0.7}{1}}\;\Varid{p}){}\<[E]%
\\
\>[36]{}\mathbin{\talloblong}{}\<[45]%
\>[45]{}\Conid{Get}\;(\lambda \Varid{t}\to \Conid{Put}\;(\Varid{prev}\;\Varid{t})\;\emptyset)){}\<[E]%
\\[\blanklineskip]%
\>[4]{}\Varid{trans}_{\scaleobj{0.7}{2}}\mathbin{::}\Conid{Prog\char95 m}\;\Varid{a}\to \Conid{Prog}\;\Varid{a}{}\<[E]%
\\
\>[4]{}\mathbin{...}{}\<[E]%
\\
\>[4]{}\Varid{trans}_{\scaleobj{0.7}{2}}\;(\Conid{Modify\char95 R}\;\Varid{next}\;\Varid{prev}\;\Varid{p}){}\<[36]%
\>[36]{}\mathrel{=}\Conid{Get}\;(\lambda \Varid{s}\to \Varid{put}_{\scaleobj{0.7}{\sf R}}\;(\Varid{next}\;\Varid{s})\;(\Varid{trans}_{\scaleobj{0.7}{2}}\;\Varid{p})){}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mathbf{where}\;\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{s}\;\Varid{p}\mathrel{=}\Conid{Get}\;(\lambda \Varid{t}\to \Conid{Put}\;\Varid{s}\;\Varid{p}\mathbin{\talloblong}\Conid{Put}\;\Varid{t}\;\emptyset){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is clear that \ensuremath{\Varid{trans}_{\scaleobj{0.7}{2}}\;\Varid{p}} is the exact same program as \ensuremath{\Varid{trans}\;\Varid{p'}}, where \ensuremath{\Varid{p'}}
is \ensuremath{\Varid{p}} but with each \ensuremath{\Conid{ModifyR}\;\Varid{next}\;\Varid{prev}\;\Varid{p}} replaced by \ensuremath{\Conid{Get}\;(\lambda \Varid{s}\to \Conid{Put}\;(\Varid{next}\;\Varid{s})\;\Varid{p})}.

We then prove that these two transformations lead to semantically identical
instances of \ensuremath{\Conid{Prog}\;\Varid{a}}.
\begin{lemma}
  \ensuremath{\Varid{run}\;(\Varid{trans}_{\scaleobj{0.7}{1}}\;\Varid{p})\mathrel{=}\Varid{run}\;(\Varid{trans}_{\scaleobj{0.7}{2}}\;\Varid{p})}. \checkmark
\end{lemma}

%\begin{align*}
%  |eval (apply C (Get (\s -> Put (next s) m)))|
%  =
%  |run (apply (transC C) (modifyR next prev (trans m)))| \mbox{~~.}
%\end{align*}


%\begin{spec}
%modifyR :: {N, S s} `sse` eps -> (s -> s) -> (s -> s) -> Me eps ()
%modifyR next prev = modify next `mplus` side (modify prev) {-"~~."-}
%\end{spec}
%%if False
%\begin{code}
%modifyR :: (MonadPlus m, MonadState s m) => (s -> s) -> (s -> s) -> m ()
%modifyR next prev =  modify next `mplus` side (modify prev) {-"~~,"-}
%\end{code}
%%endif
%One can see that |modifyR next prev >> m| expands to
%|(modify next >> m) `mplus` side (modify prev)|, thus the two |modify|s are performed before and after |m|.
%
%Assume that |s0| is the current state.
%Is it safe to replace |putR (next s0) >> m| by |modifyR next prev >> m|?
%We can do so if we are sure that |m| always restores the state to |s0| before |modify prev| is performed.
%We say that a monadic program |m| is {\em state-restoring} if, for all |comp|, the initial state in which |m >>= comp| is run is always restored when the computation finishes. Formally, it can be written as:
%\begin{definition} |m :: {N, S s} `sse` eps => Me eps a| is called {\em state-restoring} if
%  |m = get >>= \s0 -> m `mplus` side (put s0)|.
%\end{definition}
%Certainly, |putR s| is state-restoring. In fact, the following properties allow state-restoring programs to be built compositionally:
%\begin{lemma} We have that
%\begin{enumerate}
%\item |mzero| is state-restoring,
%\item |putR s| is state-restoring,
%\item |guard p >> m| is state-restoring if |m| is,
%\item |get >>= f| is state-restoring if |f x| is state-storing for all |x|, and
%\item |m >>= f| is state restoring if |m| is state-restoring.
%\end{enumerate}
%\end{lemma}
%\noindent Proof of these properties are routine exercises.
%With these properties, we also have that, for a program |m| written using our program syntax, |trans m| is always state-restoring.
%The following lemma then allows us to replace certain |putR| by |modifyR|:
%\begin{lemma} Let |next| and |prev| be such that |prev . next = id|.
%If |m| is state-restoring, we have
%%if False
%\begin{code}
%putRSRModifyR ::
%  (MonadPlus m, MonadState s m) => (s -> s) -> (s -> s) -> m b -> m b
%putRSRModifyR next prev m =
%\end{code}
%\begin{code}
%  get >>= \s -> putR (next s) >> m {-"~~"-}=== {-"~~"-}
%    modifyR next prev >> m {-"~~."-}
%\end{code}
%%endif
%\begin{equation*}
%  |get >>= \s -> putR (next s) >> m| ~=~
%    |modifyR next prev >> m| \mbox{~~.}
%\end{equation*}
%\end{lemma}

\paragraph{Backtracking using a global-state monad}
Recall that, in Section~\ref{sec:solve-n-queens},
we showed that a problem formulated by \ensuremath{\Varid{unfoldM}\;\Varid{p}\;\Varid{f}\;\Varid{z}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{assert}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})} can be solved by a hylomorphism \ensuremath{\Varid{solve}\;\Varid{p}\;\Varid{f}\;\Varid{ok}\;(\oplus)\;\Varid{st}\;\Varid{z}},
run in a non-deterministic local-state monad.
Putting all the information in this section together,
we conclude that solutions of the same problem can be computed,
in a non-deterministic global-state monad,
by \ensuremath{\Varid{run}\;(\Varid{solve}_{\scaleobj{0.7}{\sf R}}\;\Varid{p}\;\Varid{f}\;\Varid{ok}\;(\oplus)\;(\ominus)\;\Varid{st}\;\Varid{z})}, where \ensuremath{(\mathbin{\ominus}\Varid{x})\mathbin{\cdot}(\mathbin{\oplus}\Varid{x})\mathrel{=}\Varid{id}} for all \ensuremath{\Varid{x}}, and \ensuremath{\Varid{solve}_{\scaleobj{0.7}{\sf R}}} is defined by:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{solve}_{\scaleobj{0.7}{\sf R}}\mathbin{::}\{\mskip1.5mu \Conid{N},\Conid{S}\;\Varid{s}\mskip1.5mu\}\mathbin{\subseteq}\epsilon\Rightarrow {}\<[34]%
\>[34]{}(\Varid{b}\to \Conid{Bool})\to (\Varid{b}\to \Conid{M}_{\epsilon}\;(\Varid{a},\Varid{b}))\to {}\<[E]%
\\
\>[34]{}(\Varid{s}\to \Conid{Bool})\to (\Varid{s}\to \Varid{a}\to \Varid{s})\to (\Varid{s}\to \Varid{a}\to \Varid{s})\to {}\<[E]%
\\
\>[34]{}\Varid{s}\to \Varid{b}\to \Conid{M}_{\epsilon}\;[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{solve}_{\scaleobj{0.7}{\sf R}}\;\Varid{p}\;\Varid{f}\;\Varid{ok}\;(\oplus)\;(\ominus)\;\Varid{st}\;\Varid{z}\mathrel{=}\Varid{put}_{\scaleobj{0.7}{\sf R}}\;\Varid{st}\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{hyloM}\;(\odot)\;(\Varid{return}\;[\mskip1.5mu \mskip1.5mu])\;\Varid{p}\;\Varid{f}\;\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;\Varid{x}\mathbin{\odot}\Varid{m}\mathrel{=}{}\<[23]%
\>[23]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\Varid{guard}\mathbin{\cdot}\Varid{ok}\mathbin{\cdot}(\mathbin{\oplus}\Varid{x}))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[23]{}\Varid{modify}_{\scaleobj{0.7}{\sf R}}\;(\mathbin{\oplus}\Varid{x})\;(\mathbin{\ominus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}((\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{m})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that the use of \ensuremath{\Varid{run}} enforces that the program is run as a whole, that is, it cannot be further composed with other monadic programs.



\paragraph{\ensuremath{\Varid{n}}-Queens using a global state}
To wrap up, we revisit the \ensuremath{\Varid{n}}-queens puzzle.
Recall that, for the puzzle, \ensuremath{(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\oplus}\Varid{x}\mathrel{=}(\mathrm{1}\mathbin{+}\Varid{i},(\Varid{i}\mathbin{+}\Varid{x})\mathbin{:}\Varid{us},(\Varid{i}\mathbin{-}\Varid{x})\mathbin{:}\Varid{ds})}.
By defining \ensuremath{(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\ominus}\Varid{x}\mathrel{=}(\Varid{i}\mathbin{-}\mathrm{1},\Varid{tail}\;\Varid{us},\Varid{tail}\;\Varid{ds})},
we have \ensuremath{(\mathbin{\ominus}\Varid{x})\mathbin{\cdot}(\mathbin{\oplus}\Varid{x})\mathrel{=}\Varid{id}}.
One may thus compute all solutions to the puzzle,
in a scenario with a shared global state, by \ensuremath{\Varid{run}\;(\Varid{queens}_{\scaleobj{0.7}{\sf R}}\;\Varid{n})},
where \ensuremath{\Varid{queens}} expands to:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{54}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{queens}_{\scaleobj{0.7}{\sf R}}\;\Varid{n}\mathrel{=}\Varid{put}\;(\mathrm{0},[\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{queensBody}\;[\mskip1.5mu \mathrm{0}\mathinner{\ldotp\ldotp}\Varid{n}\mathbin{-}\mathrm{1}\mskip1.5mu]~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{queensBody}\;[\mskip1.5mu \mskip1.5mu]{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{return}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{queensBody}\;\Varid{xs}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Varid{select}\;\Varid{xs}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda (\Varid{x},\Varid{ys})\to {}\<[E]%
\\
\>[19]{}(\Varid{get}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}(\Varid{guard}\mathbin{\cdot}\Varid{ok}\mathbin{\cdot}(\mathbin{\oplus}\Varid{x})))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[19]{}\Varid{modify}_{\scaleobj{0.7}{\sf R}}\;(\mathbin{\oplus}\Varid{x})\;(\mathbin{\ominus}\Varid{x})\mathbin{\hstretch{0.7}{>\!\!>}}((\Varid{x}\mathbin{:})\mathrel{\raisebox{0.5\depth}{\scaleobj{0.5}{\langle}} \scaleobj{0.8}{\$} \raisebox{0.5\depth}{\scaleobj{0.5}{\rangle}}}\Varid{queensBody}\;\Varid{ys})~~,{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}\;{}\<[10]%
\>[10]{}(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\oplus}\Varid{x}{}\<[32]%
\>[32]{}\mathrel{=}(\mathrm{1}\mathbin{+}\Varid{i},{}\<[43]%
\>[43]{}(\Varid{i}\mathbin{+}\Varid{x})\mathbin{:}\Varid{us},{}\<[54]%
\>[54]{}(\Varid{i}\mathbin{-}\Varid{x})\mathbin{:}\Varid{ds}){}\<[E]%
\\
\>[10]{}(\Varid{i},\Varid{us},\Varid{ds})\mathbin{\ominus}\Varid{x}{}\<[32]%
\>[32]{}\mathrel{=}(\Varid{i}\mathbin{-}\mathrm{1},{}\<[43]%
\>[43]{}\Varid{tail}\;\Varid{us},{}\<[54]%
\>[54]{}\Varid{tail}\;\Varid{ds}){}\<[E]%
\\
\>[10]{}\Varid{ok}\;(\anonymous ,\Varid{u}\mathbin{:}\Varid{us},\Varid{d}\mathbin{:}\Varid{ds})\mathrel{=}(\Varid{u}\notin \Varid{us})\mathrel{\wedge}(\Varid{d}\notin \Varid{ds})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

% \delete{
% \paragraph{Properties} In absence of \eqref{eq:mplus-bind-dist} and \eqref{eq:mzero-bind-zero}, we instead assume the following properties.
% \begin{align}
%   |side m1 `mplus` side m2| &= |side (m1 >> m2)| \mbox{~~,}
%     \label{eq:side-side} \\
%   |put s >> (m1 `mplus` m2)| &= |(put s >> m1) `mplus` m2| \mbox{~~,}
%     \label{eq:put-mplus}\\
%   |get >>= (\x -> f x `mplus` m)| &=~ |(get >>= f) `mplus` m| \mbox{~~, |x| not free in |m|,}
%       \label{eq:get-mplus}\\
%   |(put s >> return x) `mplus`  m| &= |return x `mplus` (put s >> m)| ~~\mbox{,}
%       \label{eq:put-ret-side}\\
%   |side m `mplus` n| &=~ |n `mplus` side m| \mbox{~~, for |m :: Me N a|.}
%         \label{eq:side-nd-mplus}
% \end{align}
% %if False
% \begin{code}
% propSideSide m1 m2 = (side m1 `mplus` side m2) === side (m1 >> m2)
% propPutMPlus s m1 m2 = (put s >> (m1 `mplus` m2)) === ((put s >> m1) `mplus` m2)
% propGetMPlus f m = (get >>= (\x -> f x `mplus` m)) === ((get >>= f) `mplus` m)
% propPutRetSide s x m = ((put s >> return x) `mplus`  m) === (return x `mplus` (put s >> m))
% propSideNdMPlus m n = (side m `mplus` n) === (n `mplus` side m)
% \end{code}
% %endif
% They all show the sequential nature of |mplus| in this setting: in \eqref{eq:side-side}, adjacent |side| commands can be combined; in \eqref{eq:put-mplus} and \eqref{eq:get-mplus}, state operators bound before |mplus| branches can be bound to the leftmost branch, and in \eqref{eq:put-ret-side}, the effect of |put s >> return x| can be moved to the next branch. Finally, \eqref{eq:side-nd-mplus} allows side effects to commute with branches that only returns non-deterministic results.
% By \eqref{eq:side-side} we have
% \begin{equation}
%  |side (put s) `mplus` side (put t) = side (put t)| \mbox{~~.}
%   \label{eq:side-put-put}
% \end{equation}
% While we do not have right-distributivity in general, we may still assume distributivity for specific cases:
% \begin{align}
%  |get >>= \s -> f1 s `mplus` f2 s| &=~ |(get >>= f1) `mplus` (get >>= f2)| \mbox{~~, if |f1 s :: Me N a|}
%     \label{eq:get-mplus-distr}\\
%  |get >>= \s -> f1 s `mplus` f2 s| &=~ |(get >>= (\s -> f1 s `mplus` side (put s))) `mplus` (get >>= f2)| \mbox{~~.}
%       \label{eq:get-mplus-side-distr}
% \end{align}
% %if False
% \begin{code}
% propGetMPlusDistr f1 f2 = (get >>= \x -> f1 x `mplus` f2 x) === ((get >>= f1) `mplus` (get >>= f2))
% propGetMPlusSideDistr f1 f2 = (get >>= \x -> f1 x `mplus` f2 x) === ((get >>= (\x -> f1 x `mplus` side (put x))) `mplus` (get >>= f2))
% \end{code}
% %endif
% Property \eqref{eq:get-mplus-distr} allows right-distributivity of |get| if the branches are only non-deterministic.
% It helps to prove that |get| commutes with non-determinism.
% In general cases, we need a |side (put x)| in the first branch to ensure that the second branch gets the correct value, as in \eqref{eq:get-mplus-side-distr}.
% } %delete
%
%
% \delete{
% \subsection{State-Restoring Programs}
% \label{sec:state-restoring}
%
% In this section we present an interesting programming pattern that exploits left-distributivity \eqref{eq:bind-mplus-dist}.
% Define the following variation of |put|:%
% \footnote{The author owes the idea of |putR| to Tom Schrijvers. See Section \ref{sec:conclusion} for more details.}
%
% \begin{lemma}\label{lma:putR-basics}
% The following laws regarding |putR| are true:
% \begin{align*}
%     |putR s >>= get| ~&=~ |putR s >>= return s| \mbox{~~,} \\
%     |putR s >> putR s'| ~&=~ |putR s'|  \mbox{~~.}
% \end{align*}
% \end{lemma}
%
% \begin{lemma}\label{lma:putR-nd-commute}
% |putR| commutes with non-determinism. That is, |m >>= \x -> putR s >> return x = putR s >> m| for |m :: Me N a|.
% \end{lemma}
%
% Proof of Lemma \ref{lma:putR-basics} is a routine exercise. Lemma \ref{lma:putR-nd-commute} can be proved by induction on the syntax of |m|, using properties including \eqref{eq:side-side}, \eqref{eq:put-ret-side}, \eqref{eq:side-nd-mplus}, and \eqref{eq:get-mplus-side-distr}.
%
% % \begin{proof}
% % We present the proof for the |putR|-|putR| law for illustrative purpose. The proof demonstrates the use of \eqref{eq:put-mplus} and \eqref{eq:side-put-put}.
% % \begin{spec}
% %    putR s >> putR s'
% % =  (get >>= \s0 -> (put s `mplus` side (put s0))) >>
% %    (get >>= \s0 -> (put s' `mplus` side (put s0)))
% % =    {- left-distributivity \eqref{eq:bind-mplus-dist} -}
% %    get >>= \s0 -> (put s >> get >>= \s0 -> (put s' `mplus` side (put s0))) `mplus` side (put s0)
% % =    {- |put|-|get| \eqref{eq:get-put} -}
% %    get >>= \s0 -> (put s >> (put s' `mplus` side (put s))) `mplus` side (put s0)
% % =    {- by \eqref{eq:put-mplus} -}
% %    get >>= \s0 -> (put s >> puts') `mplus` side (put s) `mplus` side (put s0)
% % =    {- |put|-|put| \eqref{eq:put-put} and \eqref{eq:side-put-put} -}
% %    get >>= \s0 -> put s' `mplus` side (put s0)
% % =  putR s' {-"~~."-}
% % \end{spec}
% % \end{proof}
% Note that we do not have a |get|-|putR| law: |get >>= putR| does not equal |return ()|. To see that, observe that |(get >>= putR) >> put t| terminates with the initial state, while |return () >> put t| terminates with state |t|.
%
% \paragraph{State-Restoration, Compositionally} Pushing the idea a bit further, we say that a monadic program |m| is {\em state-restoring} if, for all |comp|, the initial state in which |m >>= comp| is run is always restored when the computation finishes. Formally, it can be written as:
% \begin{definition} |m :: {N, S s} `sse` eps => Me eps a| is called {\em state-restoring} if
%   |m = get >>= \s0 -> m `mplus` side (put s0)|.
% \end{definition}
% Certainly, |putR s| is state-restoring. In fact, state-restoring programs can be built compositionally, using the following properties:
% \begin{lemma} We have that
% \begin{enumerate}
% \item |mzero| is state-restoring,
% \item |putR s| is state-restoring,
% \item |guard p >> m| is state-restoring if |m| is,
% \item |get >>= f| is state-restoring if |f x| is state-storing for all |x|, and
% \item |m >>= f| is state restoring if |m| is state-restoring.
% \end{enumerate}
% \end{lemma}
% Proof of these properties are routine exercises.
%
% \paragraph{Incremental Updating and Restoration}
% Identifying state-restoring programs helps to discover when we can update and restore the state in an incremental manner.
% When the state |s| is a big structure, such as an array, it might not be feasible to perform |put s| that rewrites an entire array.
% Instead one might use another command |modify f| that applies the function |f| to the state. It can be characterised by:
% \begin{spec}
%   modify f = get >>= \s -> put (f s) {-"~~,"-}
% \end{spec}
% but one may assume that, for commands such as |modify (\arr -> arr // [(i,x)])| (where |(// [(i,x)])| updates the |i|-th entry of the array to |x|), there exists a quicker implementation that mutates the array rather than creating a new array.
%
% Given a function |next :: s -> s| that alters the state, and |prev :: s -> s| that is the inverse of |next|, we define the following state-restoring variation of |modify|:
% \begin{spec}
% modifyR :: {N, S s} `sse` eps -> (s -> s) -> (s -> s) -> Me eps ()
% modifyR next prev =  modify next `mplus` side (modify prev) {-"~~,"-}
% \end{spec}
% %if False
% \begin{code}
% modifyR :: (MonadPlus m, MonadState s m) => (s -> s) -> (s -> s) -> m ()
% modifyR next prev =  modify next `mplus` side (modify prev) {-"~~,"-}
% \end{code}
% %endif
% such that |modifyR next prev >> comp| performs |modify next| before computation in |comp|, and |modify prev| afterwards. We have that:
% \begin{lemma} Let |next| and |prev| be such that |prev . next = id|.
% If |m| is state-restoring, we have
% %if False
% \begin{code}
% putRSRModifyR ::
%   (MonadPlus m, MonadState s m) => (s -> s) -> (s -> s) -> m b -> m b
% putRSRModifyR next prev m =
% \end{code}
% %endif
% \begin{code}
%   get >>= \s -> putR (next s) >> m {-"~~"-}=== {-"~~"-}
%     modifyR next prev >> m {-"~~."-}
% \end{code}
% \end{lemma}
% We look at its proof, which demonstrates the use of \eqref{eq:side-side} -- \eqref{eq:get-mplus}, monad laws, and laws regarding |get| and |put|.
% For the rest of this paper we use the following abbreviations:
% \begin{code}
% sidePut st  = side (put st)    {-"~~,"-}
% sideMod f   = side (modify f)  {-"~~."-}
% \end{code}
% \begin{proof} We calculate:
% %if False
% \begin{code}
% putRSRModifyRDer1 ::
%   (MonadPlus m, MonadState s m) => (s -> s) -> (s -> s) -> m b -> m b
% putRSRModifyRDer1 next prev m =
% \end{code}
% %endif
% \begin{code}
%       modifyR next prev >> m
%  ===    {- definiton of |modifyR|, |modify|, and left-distributivity \eqref{eq:bind-mplus-dist} -}
%       (get >>= \s -> put (next s) >> m) `mplus` sideMod prev
%  ===    {- by \eqref{eq:get-mplus} -}
%       get >>= \s -> (put (next s) >> m) `mplus` sideMod prev {-"~~."-}
% \end{code}
% We focus on the part within |(get >>= \s -> _)|:
% %if False
% \begin{code}
% putRSRModifyRDer2 ::
%   (MonadPlus m, MonadState s m) =>
%   (s -> s) -> (s -> s) -> s -> m a -> m a
% putRSRModifyRDer2 next prev s m =
% \end{code}
% %endif
% \begin{code}
%       (put (next s) >> m) `mplus` sideMod prev
%  ===    {- |m| state-restoring -}
%       (put (next s) >> get >>= \s' -> m `mplus` sidePut s') `mplus` sideMod prev
%  ===    {- |put|-|get| \eqref{eq:get-put} -}
%       (put (next s) >> (m `mplus` sidePut (next s))) `mplus` sideMod prev
%  ===    {- by \eqref{eq:put-mplus} -}
%       put (next s) >> (m `mplus` sidePut (next s) `mplus` sideMod prev)
%  ===    {- by \eqref{eq:side-side}, and |prev . next = id| -}
%       put (next s) >> (m `mplus` sidePut s)
%  ===    {- by \eqref{eq:put-mplus} -}
%       (put (next s) >> m) `mplus` sidePut s {-"~~."-}
% \end{code}
% Put it back to the context |(get >>= \s -> _)|, and the expression simplifies to |get >>= \s -> putR (next s) >> m|.
% \end{proof}
%
% } %delete
\section{Conclusions and Related Work}
\label{sec:conclusion}

This paper started as a case study of reasoning and derivation of monadic programs.
To study the interaction between non-determinism and state, we
construct backtracking algorithms solving problems that can be specified in the form \ensuremath{\Varid{unfoldM}\;\Varid{f}\;\Varid{p}\mathrel{\hstretch{0.7}{>\!\!=\!\!\!>}}\Varid{assert}\;(\Varid{all}\;\Varid{ok}\mathbin{\cdot}\Varid{scanl}_{+}\;(\oplus)\;\Varid{st})}, for two scenarios.
In the first scenario, we assume that right-distributivity and right-zero laws hold, which imply that each non-deterministic branch has its own state.
The derivation of the backtracking algorithm works by fusing the two phases into a monadic hylomorphism.

In the second scenario we consider the case when the state is global.
We find that we may use \ensuremath{(\talloblong)} to simulate sequencing, and that the idea can be elegantly packaged into commands like \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}} and \ensuremath{\Varid{modify}_{\scaleobj{0.7}{\sf R}}}.
The interaction between global state and non-determinism turns out to be rather tricky.
For a more rigorous treatment, we enforce a more precise separation between syntax and semantics and, as a side contribution of this paper, propose a collection of \emph{global state laws} which the semantics should satisfy,
and verified in Coq that there is an implementation satisfying these laws.
With the setting up, we show that a program written for local state works for the global state scenario if we replace all occurrences of \ensuremath{\Varid{put}} by \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}.

It turns out that in derivations of programs using non-determinism and state, commutativity plays an important role. When the state is local, we have nicer properties at hand, and commutativity holds more generally.
With a shared global state, commutativity holds in limited cases.
In particular, \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}} still commutes with non-determinism.

\subsection{Related Work}
\paragraph{Prolog Four-Port Box Model}
\cite{SchrijversSlides} applied an idea, similar to \ensuremath{\Varid{put}_{\scaleobj{0.7}{\sf R}}}, to implement debugging for the {\em 4-port box model} of Prolog.
In this model, upon the first entrance of a Prolog procedure it is {\em called}; it may yield a result and {\em exits}; when the subsequent procedure fails and backtracks, it is asked to {\em redo} its computation, possibly yielding the next result; finally it may {\em fail}.
Given a Prolog procedure \ensuremath{\Varid{p}} implemented in Haskell, the following program prints debugging messages when each of the four ports are used:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\Varid{putStr}\;\text{\ttfamily \char34 call\char34}\mathbin{\talloblong}\Varid{side}\;(\Varid{putStr}\;\text{\ttfamily \char34 fail\char34}))\mathbin{\hstretch{0.7}{>\!\!>}}{}\<[E]%
\\
\>[3]{}\Varid{p}\mathrel{\hstretch{0.7}{>\!\!>\!\!=}}\lambda \Varid{x}\to {}\<[E]%
\\
\>[3]{}(\Varid{putStr}\;\text{\ttfamily \char34 exit\char34}\mathbin{\talloblong}\Varid{side}\;(\Varid{putStr}\;\text{\ttfamily \char34 redo\char34}))\mathbin{\hstretch{0.7}{>\!\!>}}\Varid{return}\;\Varid{x}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Local Algebraic Effect Theories}
In this paper, we have used two different techniques to distinguish between
effect operators from their implementations: type classes and free monads. In
both cases, the meaning of the effect operators is given by a set of externally
applied axioms.
\cite{Pretnar:19} explore another approach using algebraic
effects and handlers.
In their approach, axioms (or ``effect theories'') are encoded in the type
system: the type of an effectful function declares the operators used in the
function, as well as the equalities that handlers for these operators
should comply with.
The type of a handler indicates which operators it handles and which equations
it complies with.


% We noted that |M s a = \s -> ([a],s)| fails \eqref{eq:bind-mplus-dist} and is not a monad.
% The type |ListT (State s)| generated using the now standard Monad Transformer Library~\cite{MTL:14} expands to essentially the same implementation, and is flawed in the same way. More careful implementations of |ListT|, which does satisfy \eqref{eq:bind-mplus-dist} and the monad laws, have been proposed~\cite{Gale:07:ListT,Volkov:14:list-t}.
% Effect handlers, such as that of Wu~\cite{Wu:14:Effect} and Kiselyov and Ishii~\cite{KiselyovIshii:15:Freer}, do produce correct implementations by running the handler for non-determinism before that of state.

\paragraph{Acknowledgements} to be added.


%% Bibliography
\bibliographystyle{splncs04}
\bibliography{bib}
%\input{der-monad.bbl}

%% Appendix
\appendix

\pagebreak
\section{An Implementation of the Semantical Domain}
\label{sec:GSMonad}

We present an implementation of \ensuremath{\Conid{Dom}} that satisfies the
axioms demanded by Section~\ref{sec:ctxt-trans}.
We have proven its compliance to the axioms laid out in
Section~\ref{sec:model-global-state-sem} by writing a machine-verified proof
($\checkmark$).
We let \ensuremath{\Conid{Dom}} be the union of \ensuremath{\Conid{M}\;\Varid{s}\;\Varid{a}} for all \ensuremath{\Varid{a}} and
for a given \ensuremath{\Varid{s}}.

%\setlength{\columnsep}{-4cm}
\begin{samepage}
The implementation is based on a multiset or \ensuremath{\Conid{Bag}} data structure.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Bag}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{singleton}{}\<[12]%
\>[12]{}\mathbin{::}\Varid{a}\to \Conid{Bag}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{emptyBag}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Bag}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{sum}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Bag}\;\Varid{a}\to \Conid{Bag}\;\Varid{a}\to \Conid{Bag}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}

\begin{samepage}
We model a stateful, nondeterministic computation with global state semantics as
a function that maps an initial state onto a bag of results, and a final state.
Each result is a pair of the value returned, as well as the state at that point
in the computation.
As we mentioned in Section~\ref{sec:model-global-state-sem}, a bind operator cannot be
defined for this implementation (and this is by design),
because we retain only the final result of the branch without any information on
how to continue the branch.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{M}\;\Varid{s}\;\Varid{a}\mathrel{=}\Varid{s}\to (\Conid{Bag}\;(\Varid{a},\Varid{s}),\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}

\begin{samepage}
\ensuremath{\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}} does not modify the state and produces no results.
\ensuremath{\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}} does not modify the state and produces a single result.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}\mathbin{::}\Conid{M}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\scaleobj{0.8}{\langle}\varnothing\scaleobj{0.8}{\rangle}\mathrel{=}\lambda \Varid{s}\to (\Varid{emptyBag},\Varid{s}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\mathbin{::}\Varid{a}\to \Conid{M}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\scaleobj{0.8}{\langle}\Varid{ret}\scaleobj{0.8}{\rangle}\;\Varid{x}\mathrel{=}\lambda \Varid{s}\to (\Varid{singleton}\;(\Varid{x},\Varid{s}),\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}

\begin{samepage}
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}} simply passes along the initial state to its continuation.
  \ensuremath{\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}} ignores the initial state and calls its continuation with the given
  parameter instead.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\mathbin{::}(\Varid{s}\to \Conid{M}\;\Varid{s}\;\Varid{a})\to \Conid{M}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\scaleobj{0.8}{\langle}\Varid{get}\scaleobj{0.8}{\rangle}\;\Varid{k}\mathrel{=}\lambda \Varid{s}\to \Varid{k}\;\Varid{s}\;\Varid{s}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\mathbin{::}\Varid{s}\to \Conid{M}\;\Varid{s}\;\Varid{a}\to \Conid{M}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\scaleobj{0.8}{\langle}\Varid{put}\scaleobj{0.8}{\rangle}\;\Varid{s}\;\Varid{k}\mathrel{=}\lambda \anonymous \to \Varid{k}\;\Varid{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}

\begin{samepage}
The \ensuremath{\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}} operator runs the left computation with the initial state, then
runs the right computation with the final state of the left computation,
and obtains the final result by merging the two bags of results.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}})\mathbin{::}\Conid{M}\;\Varid{s}\;\Varid{a}\to \Conid{M}\;\Varid{s}\;\Varid{a}\to \Conid{M}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}(\Varid{xs}\mathbin{\scaleobj{0.8}{\langle[\!]\rangle}}\Varid{ys})\;\Varid{s}\mathrel{=}{}\<[19]%
\>[19]{}\mathbf{let}\;{}\<[24]%
\>[24]{}(\Varid{ansx},\Varid{s'}){}\<[37]%
\>[37]{}\mathrel{=}\Varid{xs}\;\Varid{s}{}\<[E]%
\\
\>[24]{}(\Varid{ansy},\Varid{s''}){}\<[37]%
\>[37]{}\mathrel{=}\Varid{ys}\;\Varid{s'}{}\<[E]%
\\
\>[19]{}\mathbf{in}\;(\Varid{sum}\;\Varid{ansx}\;\Varid{ansy},\Varid{s''}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{samepage}

%Text of appendix \ldots

\end{document}
