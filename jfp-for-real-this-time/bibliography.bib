@InProceedings{Pirog18,
  author       = {Maciej Pir{\'{o}}g and Tom Schrijvers and Nicolas Wu
                  and Mauro Jaskelioff},
  title        = {Syntax and Semantics for Operations with Scopes},
  year         = 2018,
  booktitle    = {Proceedings of the 33rd Annual {ACM/IEEE} Symposium
                  on Logic in Computer Science, {LICS} 2018, Oxford,
                  UK, July 09-12, 2018},
  pages        = {809-818},
  doi          = {10.1145/3209108.3209166},
  url          = {https://doi.org/10.1145/3209108.3209166},
  timestamp    = {Fri, 27 Mar 2020 08:47:04 +0100},
  biburl       = {https://dblp.org/rec/conf/lics/PirogSWJ18.bib},
  bibsource    = {dblp computer science bibliography,
                  https://dblp.org}
}

@article{Gibbons11,
author = {Gibbons, Jeremy and Hinze, Ralf},
title = {Just Do It: Simple Monadic Equational Reasoning},
year = {2011},
issue_date = {September 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2034574.2034777},
doi = {10.1145/2034574.2034777},
abstract = {One of the appeals of pure functional programming is that it is so amenable to equational
reasoning. One of the problems of pure functional programming is that it rules out
computational effects. Moggi and Wadler showed how to get round this problem by using
monads to encapsulate the effects, leading in essence to a phase distinction - a pure
functional evaluation yielding an impure imperative computation. Still, it has not
been clear how to reconcile that phase distinction with the continuing appeal of functional
programming; does the impure imperative part become inaccessible to equational reasoning?
We think not; and to back that up, we present a simple axiomatic approach to reasoning
about programs with computational effects.},
journal = {SIGPLAN Not.},
month = sep,
pages = {2–14},
numpages = {13},
keywords = {lawvere theories, equational reasoning, monads, algebraic specification}
}

@inproceedings{Wu15,
  title = {Fusion for Free: Efficient Algebraic Effect Handlers},
  author = {Nicolas Wu and Tom Schrijvers},
  year = {2015},
  booktitle = {MPC 2015},
  url = {/Research/papers/mpc2015.pdf}
}

@inproceedings{Pauwels19,
  title={Handling Local State with Global State},
  author={Pauwels, Koen and Schrijvers, Tom and Mu, Shin-Cheng},
  booktitle={International Conference on Mathematics of Program Construction},
  pages={18--44},
  year={2019},
  organization={Springer}
}

@inproceedings{Seynaeve20,
  title={State will do},
  author={Seynaeve, Willem and Pauwels, Koen and Schrijvers, Tom},
  booktitle={International Symposium on Trends in Functional Programming},
  pages={204--225},
  year={2020},
  organization={Springer}
}

@article{Moggi91,
  Author = {Moggi, Eugenio},
  Date-Added = {2017-02-08 07:14:08 +0000},
  Date-Modified = {2017-02-08 07:15:52 +0000},
  Journal = {Information and Computation},
  Number = {1},
  Pages = {55-92},
  Title = {Notions of computation and monads},
  Volume = {93},
  Year = {1991}}

@article{Pirog17,
  title        = {Backtracking with cut via a distributive law and left-zero monoids*},
  author       = {Maciej Pir{\'o}g and S. Staton},
  journal      = {Journal of Functional Programming},
  year         = {2017},
  volume       = {27}
}

@inproceedings{Plotkin02,
author = {Plotkin, Gordon D. and Power, John},
title = {Notions of Computation Determine Monads},
year = {2002},
isbn = {354043366X},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We model notions of computation using algebraic operations and equations. We show
that these generate several of the monads of primary interest that have been used
to model computational effects, with the striking omission of the continuations monad.
We focus on semantics for global and local state, showing that taking operations and
equations as primitive yields a mathematical relationship that reflects their computational
relationship.},
booktitle = {Proceedings of the 5th International Conference on Foundations of Software Science and Computation Structures},
pages = {342–356},
numpages = {15},
series = {FoSSaCS '02}
}

@article{PlotkinP03,
  author       = {Gordon D. Plotkin and
                  John Power},
  title        = {Algebraic Operations and Generic Effects},
  journal      = {Appl. Categorical Struct.},
  volume       = {11},
  number       = {1},
  pages        = {69--94},
  year         = {2003},
  url          = {https://doi.org/10.1023/A:1023064908962},
  doi          = {10.1023/A:1023064908962},
  timestamp    = {Tue, 29 Sep 2020 10:59:27 +0200},
  biburl       = {https://dblp.org/rec/journals/acs/PlotkinP03.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{Plotkin09,
author="Plotkin, Gordon
and Pretnar, Matija",
editor="Castagna, Giuseppe",
title="Handlers of Algebraic Effects",
booktitle="Programming Languages and Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="80--94",
abstract="We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.",
isbn="978-3-642-00590-9"
}

@article{Plotkin13,
  TITLE = {{Handling Algebraic Effects}},
  AUTHOR = {Gordon D Plotkin and Matija Pretnar},
  URL = {https://lmcs.episciences.org/705},
  DOI = {10.2168/LMCS-9(4:23)2013},
  JOURNAL = {{Logical Methods in Computer Science}},
  VOLUME = {{Volume 9, Issue 4}},
  YEAR = {2013},
  MONTH = Dec,
  KEYWORDS = {Computer Science - Logic in Computer Science ; Computer Science - Programming Languages},
}

@InProceedings{Wu14,
  author       = {Nicolas Wu and Tom Schrijvers and Ralf Hinze},
  title        = {Effect handlers in scope},
  year         = 2014,
  booktitle    = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on
                  Haskell, Gothenburg, Sweden, September 4-5, 2014},
  pages        = {1-12},
  doi          = {10.1145/2633357.2633358},
  url          = {https://doi.org/10.1145/2633357.2633358},
  timestamp    = {Sat, 19 Oct 2019 20:24:41 +0200},
  biburl       = {https://dblp.org/rec/conf/haskell/WuSH14.bib},
  bibsource    = {dblp computer science bibliography,
                  https://dblp.org}
}

@InProceedings{Schrijvers19,
  author       = {Tom Schrijvers and Maciej Pir{\'{o}}g and Nicolas Wu
                  and Mauro Jaskelioff},
  title        = {Monad transformers and modular algebraic effects:
                  what binds them together},
  year         = 2019,
  booktitle    = {Proceedings of the 12th {ACM} {SIGPLAN}
                  International Symposium on Haskell, Haskell, ICFP
                  2019, Berlin, Germany, August 18-23, 2019},
  pages        = {98-113},
  doi          = {10.1145/3331545.3342595},
  url          = {https://doi.org/10.1145/3331545.3342595},
  timestamp    = {Fri, 27 Mar 2020 08:57:01 +0100},
  biburl       =
                  {https://dblp.org/rec/conf/haskell/SchrijversPWJ19.bib},
  bibsource    = {dblp computer science bibliography,
                  https://dblp.org}
}

@misc{Kiselyov:15:Laws,
  Author = {Kiselyov, Oleg},
  Date-Added = {2017-02-10 05:13:59 +0000},
  Date-Modified = {2017-02-10 05:31:26 +0000},
  Howpublished = {\url{http://okmij.org/ftp/Computation/monads.html\#monadplus}},
  Title = {Laws of MonadPlus},
  Year = {2015}}

@article{Kiselyov15,
author = {Kiselyov, Oleg and Ishii, Hiromi},
title = {Freer Monads, More Extensible Effects},
year = {2015},
issue_date = {December 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/2887747.2804319},
doi = {10.1145/2887747.2804319},
abstract = { We present a rational reconstruction of extensible effects, the recently proposed
alternative to monad transformers, as the confluence of efforts to make effectful
computations compose. Free monads and then extensible effects emerge from the straightforward
term representation of an effectful computation, as more and more boilerplate is abstracted
away. The generalization process further leads to freer monads, constructed without
the Functor constraint. The continuation exposed in freer monads can then be represented
as an efficient type-aligned data structure. The end result is the algorithmically
efficient extensible effects library, which is not only more comprehensible but also
faster than earlier implementations. As an illustration of the new library, we show
three surprisingly simple applications: non-determinism with committed choice (LogicT),
catching IO exceptions in the presence of other effects, and the semi-automatic management
of file handles and other resources through monadic regions. We extensively use and
promote the new sort of `laziness', which underlies the left Kan extension: instead
of performing an operation, keep its operands and pretend it is done. },
journal = {SIGPLAN Not.},
month = aug,
pages = {94–105},
numpages = {12},
keywords = {coroutine, effect handler, effect interaction, free monad, open union, Kan extension, type and effect system}
}

@article{mcbride08,
  title={Applicative programming with effects},
  volume={18},
  DOI={10.1017/S0956796807006326},
  number={1},
  journal={Journal of Functional Programming},
  publisher={Cambridge University Press},
  author={McBride, Conor and Paterson, Ross},
  year={2008},
  pages={1–13}}

@article{Hutton08,
author = {Hutton, Graham and Fulger, Diana},
year = {2008},
month = {01},
pages = {},
title = {Reasoning About Effects: Seeing the Wood Through the Trees (Extended Version)}
}

@misc{mtl,
  author = {Jones, Mark P.},
  title = {Functional Programming with Overloading and Higher-Order Polymorphism},
  year = {1995},
  isbn = {3540594515},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  booktitle = {Advanced Functional Programming, First International Spring School on Advanced Functional Programming Techniques-Tutorial Text},
  pages = {97–136},
  numpages = {40}
}

@misc{Volkov14,
  author = {Nikita Volkov},
  title = {list-t: {ListT} done right},
  year = {2014},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/nikita-volkov/list-t}},
  commit = {e13dbfe7f897ec4d3e34d78cf8ea2bedcf9369c0}
}

@misc{Gale,
  Author = {Gale, Yitzchak},
  Date-Added = {2017-02-23 17:14:35 +0000},
  Date-Modified = {2017-03-22 12:55:42 +0000},
  Howpublished = {\url{https://wiki.haskell.org/ListT_done_right_alternative}},
  Title = {{ListT} done right alternative},
  Year = {2007}}

@inproceedings{Xu21,
  author    = {Han Xu and
               Zhenjiang Hu},
  editor    = {Nikhil Bansal and
               Emanuela Merelli and
               James Worrell},
  title     = {Analytical Differential Calculus with Integration},
  booktitle = {48th International Colloquium on Automata, Languages, and Programming,
               {ICALP} 2021, July 12-16, 2021, Glasgow, Scotland (Virtual Conference)},
  series    = {LIPIcs},
  volume    = {198},
  pages     = {143:1--143:20},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2021},
  url       = {https://doi.org/10.4230/LIPIcs.ICALP.2021.143},
  doi       = {10.4230/LIPIcs.ICALP.2021.143},
  timestamp = {Tue, 06 Jul 2021 10:05:01 +0200},
  biburl    = {https://dblp.org/rec/conf/icalp/XuH21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{YangW21,
  author    = {Zhixuan Yang and
               Nicolas Wu},
  title     = {Reasoning about effect interaction by fusion},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {5},
  number    = {{ICFP}},
  pages     = {1--29},
  year      = {2021},
  url       = {https://doi.org/10.1145/3473578},
  doi       = {10.1145/3473578},
}

@article{LuksicP20,
  author    = {Ziga Luk\v{s}i\v{c}  and
               Matija Pretnar},
  title     = {Local algebraic effect theories},
  journal   = {J. Funct. Program.},
  volume    = {30},
  pages     = {e13},
  year      = {2020},
  url       = {https://doi.org/10.1017/S0956796819000212},
  doi       = {10.1017/S0956796819000212},
}

@InProceedings{Schulte:ICLP:1999,
   Author =    "Christian Schulte",
   Title =     "Comparing Trailing and Copying for Constraint Programming",
   Editor =    "Danny De Schreye",
   Booktitle = "Proceedings of the Sixteenth International Conference on Logic Programming",
   Year =      1999,
   Address =   "Las Cruces, NM, USA",
   Publisher = "The MIT Press",
   Pages =     "275--289",
   URL =       "https://chschulte.github.io/papers/schulte-iclp-1999.html"
}

@TECHREPORT{AICPub641:1983,
  AUTHOR={Warren, David H. D.},
  TITLE={An Abstract Prolog Instruction Set},
  ADDRESS={333 Ravenswood Ave., Menlo Park, CA 94025},
  INSTITUTION={AI Center, SRI International},
  MONTH={Oct},
  NUMBER={309},
  YEAR={1983},
  KEYWORDS={Prolog},
  ABSTRACT={This report describes an abstract Prolog instruction set suitable for
     software, firmware, or hardware implementation. The instruction set is abstract
     in that certain details of its encoding and implementation are left open, so
     that it may be realized in a number of different forms. The forms that are
     contemplated are: 

 em Translation into a compact bytecode, with emulators
     written in C (for maximum portability), Progol (a macrolanguage generating
     machine code, for efficient software implementations as an alternative to direct
     compilation on machines such as the VAX), and VAX-730 microcode. em Compilation
     into the standard instructions of machines such as the VAX or DECsystem-10/20.
     em Hardware (or firmware) emulation of the instruction set on a specially designed
     Prolog processor. 
 The abstract machine described herein (``new Prolog
     Engine’’) is a major revision of the ``old Prolog Engine’’
     described in a previous document. The new model overcomes certain difficulties
     in the old model, which are discussed in a later section. The new model can
     be considered to be a modification of the old model, where the stack contains
     compiler-defined goals called environments instead of user-defined goals. The
     environments correspond to some number of goals forming the tail of a clause.
     The old model was developed having primarily in mind a VAX-730 microcode implementation.
     The new model has, in addition, been influenced by hardware implementation
     considerations, but should remain equally amenable to software or firmware
     implementation on machines such as the VAX.}
}

@article{Felleisen94,
  author    = {Andrew K. Wright and
               Matthias Felleisen},
  title     = {A Syntactic Approach to Type Soundness},
  journal   = {Inf. Comput.},
  volume    = {115},
  number    = {1},
  pages     = {38--94},
  year      = {1994},
  url       = {https://doi.org/10.1006/inco.1994.1093},
  doi       = {10.1006/inco.1994.1093},
  timestamp = {Fri, 12 Feb 2021 22:15:30 +0100},
  biburl    = {https://dblp.org/rec/journals/iandc/WrightF94.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/acmmpc/2000,
  editor    = {Roland Carl Backhouse and
               Roy L. Crole and
               Jeremy Gibbons},
  title     = {Algebraic and Coalgebraic Methods in the Mathematics of Program Construction,
               International Summer School and Workshop, Oxford, UK, April 10-14,
               2000, Revised Lectures},
  series    = {Lecture Notes in Computer Science},
  volume    = {2297},
  publisher = {Springer},
  year      = {2002},
  doi       = {10.1007/3-540-47797-7},
  isbn      = {3-540-43613-8},
  url       = {https://doi.org/10.1007/3-540-47797-7},
  timestamp = {Mon, 22 Nov 2021 12:51:26 +0100},
  biburl    = {https://dblp.org/rec/conf/acmmpc/2000.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Gibbons00,
  author       = {Jeremy Gibbons},
  editor       = {Roland Carl Backhouse and
                  Roy L. Crole and
                  Jeremy Gibbons},
  title        = {Calculating Functional Programs},
  booktitle    = {Algebraic and Coalgebraic Methods in the Mathematics of Program Construction,
                  International Summer School and Workshop, Oxford, UK, April 10-14,
                  2000, Revised Lectures},
  series       = {Lecture Notes in Computer Science},
  volume       = {2297},
  pages        = {149--202},
  publisher    = {Springer},
  year         = {2000},
  url          = {https://doi.org/10.1007/3-540-47797-7\_5},
  doi          = {10.1007/3-540-47797-7\_5},
  timestamp    = {Tue, 14 May 2019 10:00:53 +0200},
  biburl       = {https://dblp.org/rec/conf/acmmpc/Gibbons00.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{LorenzenLS23,
author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
title = {FP²: Fully in-Place Functional Programming},
year = {2023},
issue_date = {August 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {ICFP},
url = {https://doi.org/10.1145/3607840},
doi = {10.1145/3607840},
abstract = {As functional programmers we always face a dilemma: should we write purely functional code, or sacrifice purity for efficiency and resort to in-place updates? This paper identifies precisely when we can have the best of both worlds: a wide class of purely functional programs can be executed safely using in-place updates without requiring allocation, provided their arguments are not shared elsewhere. We describe a linear _fully in-place_ (FIP) calculus where we prove that we can always execute such functions in a way that requires no (de)allocation and uses constant stack space. Of course, such a calculus is only relevant if we can express interesting algorithms; we provide numerous examples of in-place functions on datastructures such as splay trees or finger trees, together with in-place versions of merge sort and quick sort. We also show how we can generically derive a map function over _any_ polynomial data type that is fully in-place. Finally, we have implemented the rules of the FIP calculus in the Koka language. Using the Perceus reference counting garbage collection, this implementation dynamically executes FIP functions in-place whenever possible.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {198},
numpages = {30},
keywords = {FBIP, Tail Recursion Modulo Cons}
}

<<<<<<< HEAD
@inproceedings{shortcut,
author = {Gill, Andrew and Launchbury, John and Peyton Jones, Simon L.},
title = {A Short Cut to Deforestation},
year = {1993},
isbn = {089791595X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/165180.165214},
doi = {10.1145/165180.165214},
booktitle = {Proceedings of the Conference on Functional Programming Languages and Computer Architecture},
pages = {223–232},
numpages = {10},
location = {Copenhagen, Denmark},
series = {FPCA '93}
}

@techreport{monadicbacktracking,
  author = {Ralf Hinze},
  title = {Monadic-style backtracking},
  institution = {Institut f\"{u}r Informatik III, Universit\"{a}t Bonn}, 
  type = { Technical Report},
  number = {IAI-TR-96-9},
  month = {October},
  year = {1996},
}

@inproceedings{Reynolds83,
  author       = {John C. Reynolds},
  editor       = {R. E. A. Mason},
  title        = {Types, Abstraction and Parametric Polymorphism},
  booktitle    = {Information Processing 83, Proceedings of the {IFIP} 9th World Computer
                  Congress, Paris, France, September 19-23, 1983},
  pages        = {513--523},
  publisher    = {North-Holland/IFIP},
  year         = {1983},
  timestamp    = {Sun, 28 Jul 2019 17:03:41 +0200},
  biburl       = {https://dblp.org/rec/conf/ifip/Reynolds83.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Wadler89,
  author       = {Philip Wadler},
  editor       = {Joseph E. Stoy},
  title        = {Theorems for Free!},
  booktitle    = {Proceedings of the fourth international conference on Functional programming
                  languages and computer architecture, {FPCA} 1989, London, UK, September
                  11-13, 1989},
  pages        = {347--359},
  publisher    = {{ACM}},
  year         = {1989},
  url          = {https://doi.org/10.1145/99370.99404},
  doi          = {10.1145/99370.99404},
  timestamp    = {Wed, 14 Nov 2018 10:57:36 +0100},
  biburl       = {https://dblp.org/rec/conf/fpca/Wadler89.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@book{AitKaci91,
  author       = {Hassan A{\"{\i}}t{-}Kaci},
  title        = {Warren's Abstract Machine: {A} Tutorial Reconstruction},
  publisher    = {{MIT} Press},
  year         = {1991},
  isbn         = {0-262-01123-9},
  timestamp    = {Thu, 03 Jan 2002 11:51:26 +0100},
  biburl       = {https://dblp.org/rec/books/mit/AitKaci91.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{BergS23,
  author       = {Birthe van den Berg and
                  Tom Schrijvers},
  title        = {A Framework for Higher-Order Effects {\&} Handlers},
  journal      = {CoRR},
  volume       = {abs/2302.01415},
  year         = {2023},
  url          = {https://doi.org/10.48550/arXiv.2302.01415},
  doi          = {10.48550/ARXIV.2302.01415},
  eprinttype    = {arXiv},
  eprint       = {2302.01415},
  timestamp    = {Thu, 09 Feb 2023 16:11:17 +0100},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2302-01415.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{YangPWBS22,
  author       = {Zhixuan Yang and
                  Marco Paviotti and
                  Nicolas Wu and
                  Birthe van den Berg and
                  Tom Schrijvers},
  editor       = {Ilya Sergey},
  title        = {Structured Handling of Scoped Effects},
  booktitle    = {Programming Languages and Systems - 31st European Symposium on Programming,
                  {ESOP} 2022, Held as Part of the European Joint Conferences on Theory
                  and Practice of Software, {ETAPS} 2022, Munich, Germany, April 2-7,
                  2022, Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {13240},
  pages        = {462--491},
  publisher    = {Springer},
  year         = {2022},
  url          = {https://doi.org/10.1007/978-3-030-99336-8\_17},
  doi          = {10.1007/978-3-030-99336-8\_17},
  timestamp    = {Fri, 29 Apr 2022 14:50:41 +0200},
  biburl       = {https://dblp.org/rec/conf/esop/YangPWBS22.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@misc{wam,
  title = "A Functional Derivation of the Warren Abstract Machine",
  author = "Maciej Pirog and Jeremy Gibbons",
  year = "2011",
  note = "Unpublished",
  url = "http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/wam.pdf",
}


@article{AGER2005149,
	abstract = {We extend our correspondence between evaluators and abstract machines from the pure setting of the λ-calculus to the impure setting of the computational λ-calculus. We show how to derive new abstract machines from monadic evaluators for the computational λ-calculus. Starting from (1) a generic evaluator parameterized by a monad and (2) a monad specifying a computational effect, we inline the components of the monad in the generic evaluator to obtain an evaluator written in a style that is specific to this computational effect. We then derive the corresponding abstract machine by closure-converting, CPS-transforming, and defunctionalizing this specific evaluator. We illustrate the construction with the identity monad, obtaining the CEK machine, and with a lifted state monad, obtaining a variant of the CEK machine with error and state. In addition, we characterize the tail-recursive stack inspection presented by Clements and Felleisen as a lifted state monad. This enables us to combine this stack-inspection monad with other monads and to construct abstract machines for languages with properly tail-recursive stack inspection and other computational effects. The construction scales to other monads---including one more properly dedicated to stack inspection than the lifted state monad---and other monadic evaluators.},
	author = {Mads Sig Ager and Olivier Danvy and Jan Midtgaard},
	doi = {https://doi.org/10.1016/j.tcs.2005.06.008},
	issn = {0304-3975},
	journal = {Theoretical Computer Science},
	keywords = {-calculus, Interpreters, Abstract machines, Closure conversion, Transformation into continuation-passing style (CPS), Defunctionalization, Monads, Effects, Proper tail recursion, Stack inspection},
	note = {Applied Semantics: Selected Topics},
	number = {1},
	pages = {149-172},
	title = {A functional correspondence between monadic evaluators and abstract machines for languages with computational effects},
	url = {https://www.sciencedirect.com/science/article/pii/S0304397505003439},
	volume = {342},
	year = {2005},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S0304397505003439},
	bdsk-url-2 = {https://doi.org/10.1016/j.tcs.2005.06.008}}


@incollection{DBLP:books/el/beierleP95/BorgerR95,
  author       = {Egon B{\"{o}}rger and
                  Dean Rosenzweig},
  editor       = {Christoph Beierle and
                  Lutz Pl{\"{u}}mer},
  title        = {The {WAM} - Definition and Compiler Correctness},
  booktitle    = {Logic Programming: Formal Methods and Practical Applications, Studies
                  in Computer Science and Artificial Intelligence},
  pages        = {20--90},
  publisher    = {Elsevier Science B.V./North-Holland},
  year         = {1995},
  timestamp    = {Mon, 05 Aug 2019 11:57:50 +0200},
  biburl       = {https://dblp.org/rec/books/el/beierleP95/BorgerR95.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.5555/646523.694570,
author = {Pusch, Cornelia},
title = {Verification of Compiler Correctness for the WAM},
year = {1996},
isbn = {3540615873},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 9th International Conference on Theorem Proving in Higher Order Logics},
pages = {347–361},
numpages = {15},
series = {TPHOLs '96}
}
