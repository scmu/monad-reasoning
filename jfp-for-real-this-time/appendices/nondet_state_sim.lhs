\section{Simulating Nondeterminism with State: The Proofs}
%-------------------------------------------------------------------------------
\subsection{Only State and Nondeterminism}
\label{app:runnd-hnd}

This section shows that the |runND| function in Section \ref{sec:sim-nondet-state} is equivalent
to the following nondeterminism handler |hND| in Section \ref{sec:combining-effects}.

\begin{theorem}\label{eq:runnd-hnd}
|runND = hND|
\end{theorem}
\begin{proof}
We start with expanding the definition of |runND|:
< extractS . hState' . nondet2stateS = hND
Both |nondet2stateS| and |hND| are written as a fold.
We can use the universal property of fold to show that the two sides of the equation
are equal.
For this, we use the fold fusion law for postcomposition as defined in 
Equation \ref{eq:fusion-post}.

We have to prove the following two equations.
\begin{enumerate}
    \item |(extractS . hState') . gen = genND|
    \item |(extractS . hState') . alg = algND . fmap (extractS . hState')|
\end{enumerate}

The first equation is simple to prove with equational reasoning.
For all input |x|, we need to prove that |extractS (hState' (gen x)) = genND x|
<    extractS (hState' (gen x))
< = {-~  definition of |gen|  -}
<    extractS (hState' (appendS x popS))

< = {-~  definition of |extractS|  -}
<    results . snd $ runState (hState' (appendS x popS)) (S [] [])
< = {-~  Lemma \ref{eq:eval-append}  -}
<    results . snd $ runState (hState' popS) (S ([] ++ [x]) [])
< = {-~  definition of |(++)|  -}
<    results . snd $ runState (hState' popS) (S [x] [])
< = {-~  Lemma \ref{eq:eval-pop1}  -}
<    results . snd $ ((), S [x] [])
< = {-~  definition of |snd|  -}
<    results (S [x] [])
< = {-~  definition of |results|  -}
<    [x]
< = {-~  definition of |return|  -}
<    return x
< = {-~  definition of |genND|  -}
<    genND x

The property that |extractS . hState' . gen = return| is called 
\emph{extract-gen}\label{eq:extract-gen}.

For the second equation that we have to prove, we do a case analysis.

% \fbox{|Fail|}
\noindent
\mbox{\underline{case |Fail|}}

<    extractS (hState' (alg Fail))
< = {-~  definition of |alg|  -}
<    extractS (hState' popS)
< = {-~  definition of |extractS|  -}
<    results . snd $ runState (hState' popS) (S [] [])
< = {-~  Lemma \ref{eq:eval-pop1}  -}
<    results . snd $ ((), S [] [])
< = {-~  evaluation of |results|, |snd|  -}
<    []
< = {-~  definition of |algND|  -}
<    algND Fail
< = {-~  definition of |fmap|  -}
<    (algND . fmap (extractS . hState')) Fail
The property that |extractS (hState' (alg Fail)) = []| is called 
\emph{extract-alg-1}\label{eq:extract-alg-1}.

% \fbox{|Or p q|}
\noindent
\mbox{\underline{case |Or p q|}}

<    extractS (hState' (alg (Or p q)))
< = {-~  definition of |alg|  -}
<    extractS (hState' (pushS q p))
< = {-~  definition of |extract|  -}
<    results . snd $ runState (hState' (pushS q p)) (S [] [])
< = {-~  Lemma \ref{eq:eval-push}  -}
<    results . snd $ runState (hState' p) (S [] [q])
< = {-~  property pop-extract (\ref{eq:pop-extract}) for |p|  -}
<    results . snd $ runState (hState' popS) (S ([] ++ extractS (hState' p)) [q])
< = {-~  definition of |(++)|  -}
<    results . snd $ runState (hState' popS) (S (extractS (hState' p)) [q])
< = {-~  Lemma \ref{eq:eval-pop2}  -}
<    results . snd $ runState (hState' q) (S (extractS (hState' p)) [])
< = {-~  property pop-extract (\ref{eq:pop-extract}) for |q|  -}
<    results . snd $ runState (hState' popS) (S (extractS (hState' p) ++ extractS (hState' q)) [])
< = {-~  Lemma \ref{eq:eval-pop1}  -}
<    results . snd $ ((), S (extractS (hState' p) ++ extractS (hState' q)) [])
< = {-~  evaluation of |results, snd|  -}
<    extractS (hState' p) ++ extractS (hState' q)
< = {-~  definition of |algND|  -}
<    algND (Or ((extractS . hState') p) ((extractS . hState') q))
< = {-~  definition of |fmap|  -}
<    (algND . fmap (extractS . hState')) (Or p q)

The property that |extractS (hState' (alg (Or p q))) = extractS (hState' p) ++ extractS (hState' q)|
is called \emph{extract-alg-2}\label{eq:extract-alg-2}.
\end{proof}

%if False
$
%endif

In this proof we have used the property pop-extract, which states the following: 
\begin{theorem}[pop-extract]\label{eq:pop-extract}
~
% <    runState (runSTND p) (q, stack) = runState (runSTND popND) (q `mplus` extract p, stack)
<    runState (hState' p) (S xs stack) = runState (hState' popS) (S (xs ++ extractS (hState' p)) stack)
holds for all |p| in the domain of the function |nondet2stateS|.
\end{theorem}
We call this property the pop-extract property.
The key element to have this property is to 
only utilize a subset of terms with type |Comp (S a) ()|, namely those
that are generated by the fold of the |nondet2stateS| function,
so for which this property is true.
Indeed, we only generate such terms.
To prove this, we need to show that 
(1) the generator of |nondet2stateS| only generates programs of this subset;
and (2) the algebra preserves this property.

\begin{proof} ~
First, we use equational reasoning to prove the first item:
% <   runState (runSTND (gen x)) (q, stack) = runState (runSTND popND) (xs `mplus` extract (gen x), stack)
<    runState (hState' (gen x)) (S xs stack) = runState (hState' popS) (S (xs ++ extractS (hState' (gen x))) stack)

<    runState (hState' (gen x)) (S xs stack)
< = {-~  definition of |gen|  -}
<    runState (hState' (appendS x popS)) (S xs stack)
< = {-~  Lemma \ref{eq:eval-append}  -}
<    runState (hState' popS) (S (xs ++ [x]) stack)
< = {-~  definition of |return|  -}
<    runState (hState' popS) (S (xs ++ return x) stack)
< = {-~  property extract-gen (\ref{eq:extract-gen})  -}
<    runState (hState' popS) (S (xs ++ extractS (hState' (gen x))) stack)

% <    runState (runSTND (gen x)) (q, stack)
% < = {-~  definition of |gen|  -}
% <    runState (runSTND (appendND x popND)) (q, stack)
% < = {-~  evaluation of |appendND|  -}
% <    runState (runSTND popND) (xs `mplus` return x, stack)
% < = {-~  property extract-gen (\ref{eq:extract-gen})  -}
% <    runState (runSTND popND) (xs `mplus` extract (gen x), stack)

Then, we use equational reasoning with case analysis and structural induction on |x| to prove the second item:
% <     runState (runSTND (alg x)) (q, stack) = runState (runSTND popND) (xs `mplus` extract (alg x), stack)
<    runState (hState' (alg x)) (S xs stack) = runState (hState' popS) (S (xs ++ extractS (hState' (alg x))) stack)

\noindent
\mbox{\underline{case |Fail|}}

<    runState (hState' (alg Fail)) (S xs stack)
< = {-~  definition of |alg|  -}
<    runState (hState' (popS)) (S xs stack)
< = {-~  definition of |[]|  -}
<    runState (hState' popS) (S (xs ++ []) stack)
< = {-~  property extract-alg-1 (\ref{eq:extract-alg-1})  -}
<    runState (hState' popS) (S (xs ++ extractS (hState' (alg Fail))) stack)

% \fbox{|Or p1 p2|}
\noindent
\mbox{\underline{case |Or p1 p2|}}

Assume that |p1| and |p2| satisfy this theorem.

<    runState (hState' (alg (Or p1 p2))) (S xs stack)
< = {-~  definition of |alg|  -}
<    runState (hState' (pushS p2 p1)) (S xs stack)
< = {-~  Lemma \ref{eq:eval-push}  -}
<    runState (hState' p1) (S xs (p2:stack))
< = {-~  induction: property pop-extract of |p1|  -}
<    runState (hState' popS) (S (xs ++ extractS (hState' p1)) (p2:stack))
< = {-~  Lemma \ref{eq:eval-pop2}  -}
<    runState (hState' p2) (S (xs ++ extractS (hState' p1)) stack)
< = {-~  induction: property pop-extract of |p2|  -}
<    runState (hState' popS) (S (xs ++ extractS (hState' p1) ++ extractS (hState' p2)) stack)
< = {-~  property extract-alg-2 (\ref{eq:extract-alg-2})  -}
<    runState (hState' popS) (S (xs ++ hState' (alg (Or p1 p2))) stack)

Note that the above two proofs of theorems \ref{eq:runnd-hnd} and \ref{eq:pop-extract} are mutually recursive. However, only the 
second proof uses induction. As we work inductively on (smaller) subterms,
the proofs do work out. 
\end{proof}

We also have the following lemmas used in the above proof:

\begin{lemma}[evaluation-append]\label{eq:eval-append}~
< runState (hState' (appendS x p)) (S xs stack) = runState (hState' p) (S (xs ++ [x]) stack)
\end{lemma}
\begin{proof}~
<    runState (hState' (appendS x p)) (S xs stack)
< = {-~  definition of |appendS|  -}
<    runState (hState' (do S xs stack <- getS; putS (S (xs ++ [x]) stack); p)) (S xs stack)
< = {-~  definition of |do|  -}
<    runState (hState' (getS >>= \ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p)) (S xs stack)
< = {-~  definition of |getS|  -}
<    runState (hState' (Op (Get return) >>= \ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p)) (S xs stack)
< = {-~  definition of |(>>=)|  -}
<    runState (hState' (Op (Get (\ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p)))) (S xs stack)
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' ((\ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p) s)) s))
<      (S xs stack)
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' ((\ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p) s)) s) (S xs stack)
< = {-~  function application  -}
<    runState (hState' ((\ (S xs stack) -> putS (S (xs ++ [x]) stack) >> p) (S xs stack))) (S xs stack)
< = {-~  function application  -}
<    runState (hState' (putS (S (xs ++ [x]) stack) >> p)) (S xs stack)
< = {-~  definition of |putS|  -}
<    runState (hState' (Op (Put (S (xs ++ [x]) stack) (return ())) >> p)) (S xs stack)
< = {-~  definition of |(>>)|  -}
<    runState (hState' (Op (Put (S (xs ++ [x]) stack) p))) (S xs stack)
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' p) (S (xs ++ [x]) stack))) (S xs stack)
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' p) (S (xs ++ [x]) stack)) (S xs stack)
< = {-~  function application  -}
<    runState (hState' p) (S (xs ++ [x]) stack)
\end{proof}

\begin{lemma}[evaluation-pop1]\label{eq:eval-pop1}~
< runState (hState' popS) (S xs []) = ((), S xs [])
\end{lemma}
\begin{proof}
To prove this lemma, we restate the definition of |popS| using the definition of |do|:
< popS =  (getS >>= \ (S xs stack) ->
<           case stack of  []       -> return ()
<                          op : ps  -> do putS (S xs ps); op)

Then we use the equational reasoning.

<    runState (hState' popS) (S xs [])
< = {-~  definition of |popS|  -}
<    runState (hState' (getS >>= \ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)) (S xs [])
< = {-~  definition of |getS|  -}
<    runState (hState' (Op (Get return) >>= \ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)) (S xs [])
< = {-~  definition of |(>>=)|  -}
<    runState (hState' (Op (Get (\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)))) (S xs [])
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) s)) s)) (S xs [])
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) s)) s) (S xs [])
< = {-~  function application  -}
<    runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) (S xs []))) (S xs [])
< = {-~  function application, definition of |case|  -}
<    runState (hState' (return ())) (S xs [])
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> ((), s))) (S xs [])
< = {-~  definition of |runState|  -}
<    ((), S xs [])
\end{proof}

\begin{lemma}[evaluation-pop2]\label{eq:eval-pop2}~
< runState (hState' popS) (S xs (q:stack)) = runState (hState' q) (S xs stack)
\end{lemma}
\begin{proof}~
<    runState (hState' popS) (S xs (q:stack))
< = {-~  definition of |popS|  -}
<    runState (hState' (getS >>= \ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)) (S xs (q:stack))
< = {-~  definition of |getS|  -}
<    runState (hState' (Op (Get return) >>= \ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)) (S xs (q:stack))
< = {-~  definition of |(>>=)|  -}
<    runState (hState' (Op (Get (\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op)))) (S xs (q:stack))
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) s)) s)) (S xs (q:stack))
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) s)) s) (S xs (q:stack))
< = {-~  function application  -}
<    runState (hState' ((\ (S xs stack) ->
<      case stack of  []       -> return ()
<                     op : ps  -> do putS (S xs ps); op) (S xs (q:stack)))) (S xs (q:stack))
< = {-~  function application, definition of |case|  -}
<    runState (hState' (do putS (S xs stack); q)) (S xs (q:stack))
< = {-~  definition of |do|  -}
<    runState (hState' (putS (S xs stack) >> q)) (S xs (q:stack))
< = {-~  definition of |putS|  -}
<    runState (hState' (Op (Put (S xs stack) (return ())) >> q)) (S xs (q:stack))
< = {-~  definition of |(>>)|  -}
<    runState (hState' (Op (Put (S xs stack) q))) (S xs (q:stack))
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' q) (S xs stack))) (S xs (q:stack))
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' q) (S xs stack)) (S xs (q:stack))
< = {-~  function application  -}
<    runState (hState' q) (S xs stack)
\end{proof}

\begin{lemma}[evaluation-push]\label{eq:eval-push}~
< runState (hState' (pushS q p)) (S xs stack) = runState (hState' p) (S xs (q:stack))
\end{lemma}
\begin{proof}~
<    runState (hState' (pushS q p)) (S xs stack)
< = {-~  function application  -}
<    runState (hState' (do S xs stack <- getS; putS (S xs (q : stack)); p)) (S xs stack)
< = {-~  definition of |do|  -}
<    runState (hState' (getS >>= \ (S xs stack) -> putS (S xs (q : stack)) >> p)) (S xs stack)
< = {-~  definition of |getS|  -}
<    runState (hState' (Op (Get return) >>= \ (S xs stack) -> putS (S xs (q : stack)) >> p)) (S xs stack)
< = {-~  definition of |(>>=)|  -}
<    runState (hState' (Op (Get (\ (S xs stack) -> putS (S xs (q : stack)) >> p)))) (S xs stack)
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' ((\ (S xs stack) -> putS (S xs (q : stack)) >> p) s)) s)) (S xs stack)
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' ((\ (S xs stack) -> putS (S xs (q : stack)) >> p) s)) s) (S xs stack)
< = {-~  function application  -}
<    runState (hState' ((\ (S xs stack) -> putS (S xs (q : stack)) >> p) (S xs stack))) (S xs stack)
< = {-~  function application  -}
<    runState (hState' (putS (S xs (q : stack)) >> p)) (S xs stack)
< = {-~  definition of |putS|  -}
<    runState (hState' (Op (Put (S xs (q : stack)) (return ())) >> p)) (S xs stack)
< = {-~  definition of |(>>)|  -}
<    runState (hState' (Op (Put (S xs (q : stack)) p))) (S xs stack)
< = {-~  definition of |hState'|  -}
<    runState (State (\s -> runState (hState' p) (S xs (q : stack)))) (S xs stack)
< = {-~  definition of |runState|  -}
<    (\s -> runState (hState' p) (S xs (q : stack))) (S xs stack)
< = {-~  function application  -}
<    runState (hState' p) (S xs (q : stack))

\end{proof}

%-------------------------------------------------------------------------------
\subsection{In Combination with Other Effects}
\label{app:in-combination-with-other-effects}

This section shows that the |runNDf| function of
Section \ref{sec:combining-the-simulation-with-other-effects}
is equivalent to 
the following nondeterminism handler.

< hNDf :: (Functor f, MNondet m) => Free (NondetF :+: f) a -> Free f (m a)
< hNDf = fold genNDf algNDf
<   where 
<     genNDf = Var . return 
<     algNDf (Inl Fail)      = Var mzero
<     algNDf (Inl (Or p q))  = mplus <$> p <*> q
<     algNDf (Inr y)         = Op y

%if False
$
% only to make my syntax highlighting correct
%endif

\begin{theorem}
|runNDf = hNDf|
\end{theorem}
\begin{proof}
As before, we first expand the definition of |runNDf|, 
which is written in terms of |simulate'|, a fold. 
We use fold fusion to incorporate |extractNDf| in the fold of |simulate'|.
The universal property of fold then teaches us that |runNDf| and
|hNDf| are equal.
More concretely, we have to prove the following two things:
\begin{enumerate}
    \item |extractNDf . gen' = genNDf|
    \item |extractNDf . alg' = algNDf . fmap extractNDf|
\end{enumerate}
For the first item we use simple equational reasoning techniques.
<    extractNDf (gen' x)
< = {-~  definition of |gen'|  -}
<    extractNDf (appendNDf x popNDf)
< = {-~  definition of |extractNDf|  -}
<    fst . snd <$> runStateT (runSTNDf (appendNDf x popNDf)) (mzero, [])
< = {-~  evaluation of |appendNDf|  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (mzero `mplus` return x, [])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (return x, [])
< = {-~  evaluation of |runSTNDf popNDf|, |runStateT|  -}
<    fst . snd <$> Var ((), (return x, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var (return x)
< = {-~  definition of |genNDf|  -}
<    genNDf x

For the second item that we have to prove, we do a case analysis.

% \fbox{|Inl Fail|}
\noindent \mbox{\underline{case |Inl Fail|}}

<    extractNDf (alg' (Inl Fail))
< = {-~  definition of |alg'|  -}
<    extractNDf popNDf
< = {-~  definition of |extractNDf|  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (mzero, [])
< = {-~  evaluation of |runSTNDf popNDf|, |runStateT|  -}
<    fst . snd <$> Var ((), (mzero, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var mzero
< = {-~  definition of |algNDf|  -}
<    algNDf (Inl Fail)
< = {-~  definition of |fmap|  -}
<    (algNDf . fmap extractNDf) (Inl Fail)

% \fbox{|Inl (Or p q)|}
\noindent \mbox{\underline{case |Inl (Or p q)|}}

<    extractNDf (alg' (Inl (Or p q)))
< = {-~  definition of |alg'|  -}
<    extractNDf (pushNDf q p)
< = {-~  definition of |extractNDf|  -}
<    fst . snd <$> runStateT (runSTNDf (pushNDf q p)) (mzero, [])
< = {-~  evaluation of |pushNDf q p|  -}
<    fst . snd <$> runStateT (runSTNDf p) (mzero, [q])
< = {-~  property pop-extract for |p|  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (mzero `mplus` extractNDf p, [q])
< = {-~  identity of |mzero| (\ref{eq:mzero})  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (extractNDf p, [q])
< = {-~  evaluation of |popNDf|  -}
<    fst . snd <$> runStateT (runSTNDf q) (extractNDf p, []) 
< = {-~  property pop-extract for |q|  -}
<    fst . snd <$> runStateT (runSTNDf popNDf) (extractNDf p `mplus` extractNDf q, []) 
< = {-~  evaluation of |runSTNDf popNDf|, |runStateT|  -}
<    fst . snd <$> Var ((), (extractNDf p `mplus` extractNDf q, []))
< = {-~  evaluation of |fst|, |snd|  -}
<    Var (extractNDf p `mplus` extractNDf q)
< = {-~  definition of |liftA2|  -}
<    mplus <$> extractNDf p <*> extractNDf q
< = {-~  definition of |algNDf|  -}
<    algNDf (Inl (Or (extractNDf p) (extractNDf q)))
< = {-~  definition of |fmap|  -}
<    (algNDf . fmap extractNDf) (Inl (Or p q))

% \fbox{|Inr y|}
\noindent \mbox{\underline{case |Inr y|}}

<    extractNDf (alg' (Inr y))
< = {-~  definition of |alg'|  -}
<    extractNDf (STNDf $ join $ lift $ Op (return . runSTNDf <$> y))
< = {-~  definition of |extractNDf|  -}
<    fst . snd <$> runStateT (runSTNDf (STNDf $ join $ lift $ Op (return . runSTNDf <$> y))) (mzero, [])
< = {-~  |runSTNDf . STNDf = id|  -}
<    fst . snd <$> runStateT (join $ lift $ Op (return . runSTNDf <$> y)) (mzero, [])
< = {-~  definition of |join| for |StateT|  -}
<    fst . snd <$> runStateT 
<        (StateT $ \ s -> runStateT (lift $ Op (return . runSTNDf <$> y)) s >>= \(x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  |runStateT . StateT = id|  -}
<    fst . snd <$> 
<        (\ s -> runStateT (lift $ Op (return . runSTNDf <$> y)) s >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  definition of |lift|  -}
<    fst . snd <$> 
<        (\ s -> runStateT (StateT $ \ s -> Op (return . runSTNDf <$> y) 
<             >>= \ x -> return (x, s)) s 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  |runStateT . StateT = id|  -}
<    fst . snd <$> 
<        (\ s -> (\ s -> Op (return . runSTNDf <$> y) 
<             >>= \ x -> return (x, s)) s 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  application  -}
<    fst . snd <$> 
<        (\ s -> Op (return . runSTNDf <$> y) 
<             >>= \ x -> return (x, s) 
<             >>= \ (x', s') -> runStateT x' s') 
<        (mzero, [])
< = {-~  simplification  -}
<    fst . snd <$> 
<        (\ s -> Op (return . runSTNDf <$> y) >>= \ x -> runStateT x s) 
<        (mzero, [])
< = {-~  application  -}
<    fst . snd <$> (Op (return . runSTNDf <$> y) >>= \ x -> runStateT x (mzero, []))
< = {-~  definition of |>>=| for |Op|   -}
<    fst . snd <$> Op (fmap (>>= \ x -> runStateT x (mzero, [])) (fmap (return . runSTNDf) y))
< = {-~  functor law: composition of |fmap| (\ref{eq:functor-composition}) -}
<    fst . snd <$> Op (fmap ((>>= \ x -> runStateT x (mzero, [])) . return . runSTNDf) y)
< = {-~  monad law return-bind (\ref{eq:monad-ret-bind}) -}
<    fst . snd <$> Op (fmap ((\ x -> runStateT x (mzero, [])) . runSTNDf) y)
< = {-~  simplification -}
<    fst . snd <$> Op (fmap (\ x -> runStateT (runSTNDf x) (mzero, [])) y)
< = {-~  definition of |fmap| for |Free| -}
<    Op (fmap (fmap (fst . snd)) (fmap (\ x -> runStateT (runSTNDf x) (mzero, [])) y))
< = {-~  functor law: composition of |fmap| (\ref{eq:functor-composition}) -}
<    Op (fmap ((fmap (fst . snd)) . (\ x -> runStateT (runSTNDf x) (mzero, []))) y)
< = {-~  simplification -}
<    Op (fmap (\x -> fst . snd <$> runStateT (runSTNDf x) (mzero, [])) y)
< = {-~  definition of |extractNDf|  -}
<    Op (fmap extractNDf y)
< = {-~  definition of |algNDf|  -}
<    algNDf (Inr (fmap extractNDf y))
< = {-~  definition of |fmap| for coproduct  -}
<    (algNDf (fmap extractNDf (Inr y))
< = {-~  reformulation  -}
<    (algNDf . fmap extractNDf) (Inr y)
\end{proof}


In this proof we have also used the pop-extract property of |STNDf|, which is similar to the pop-extract of |STND| (Theorem \ref{eq:pop-extract}).
\begin{theorem}[pop-extract of |STNDf|]\label{eq:pop-extract-f}
\,
<    runStateT (runSTNDf p) (q, stack) = runStateT (runSTNDf popNDf) (q `mplus` extract' p, stack)
holds for all |p| in the domain of the function |simulate'|.
\end{theorem}

\wenhao{Should we include the proof of it?}




